# Práctica 1 — La imagen digital como matrices (Python + OpenCV)

## Objetivo

Que el estudiante **comprenda la representación matricial de una imagen** (escala de grises y color), **inspeccione píxeles individuales**, **separe y vuelva a combinar canales**, y distinga **formatos y rangos** (`uint8` vs `float32`) utilizando Python y OpenCV.

## Competencias específicas

* Representa imágenes como matrices y manipula sus elementos (píxeles).
* Interpreta dimensiones, orden de índices y canales de color en OpenCV.
* Realiza operaciones básicas de lectura, escritura y visualización de imágenes.

## Material y software

* PC con Python 3.10+
* Librerías: `opencv-python`, `numpy`, `matplotlib`

  ```bash
  pip install opencv-python numpy matplotlib
  ```
* Editor (VS Code / Jupyter / PyCharm).

> Nota: OpenCV **usa BGR** por defecto (no RGB). Matplotlib espera **RGB**.

---

## 1) Fundamentos 

* **Imagen en escala de grises**: una **matriz 2D** de tamaño `(alto, ancho)`, con valores de 0 a 255 si es `uint8`.
* **Imagen en color (BGR)**: un **arreglo 3D** `(alto, ancho, 3)`; cada píxel es un triplete **(B, G, R)**.
* **Coordenadas**: el píxel en la fila `i` y columna `j` se accede como `img[i, j]`. El origen `(0, 0)` está **arriba-izquierda**.
* **Tipos y rangos**:

  * `uint8` → 0..255 (enteros, saturación con `cv2.add`, desbordamiento con `+` de NumPy).
  * `float32` → comúnmente 0..1 tras normalizar.

---

## 2) Actividad A — Imagen *grayscale* como matriz 2D

Crea un archivo `practica_1.py` y pega el siguiente bloque:

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

# ---------- A1. Crear matriz 2D (escala de grises) ----------
gray = np.array([
    [  0,  50, 100, 150, 200],
    [ 10,  60, 110, 160, 210],
    [ 20,  70, 120, 170, 220],
    [ 30,  80, 130, 180, 230],
    [ 40,  90, 140, 190, 240]
], dtype=np.uint8)

print("gray.shape:", gray.shape)   # (5, 5)
print("gray.dtype:", gray.dtype)   # uint8
print("gray[2, 3]:", gray[2, 3])   # valor del píxel fila 2, col 3

# ---------- A2. Modificar subregión (esquina superior izquierda) ----------
gray[0:2, 0:2] = 255  # saturar 2x2 a blanco

# ---------- A3. Guardar y visualizar ----------
cv2.imwrite("A_grayscale.png", gray)

plt.figure()
plt.imshow(gray, cmap="gray", vmin=0, vmax=255)
plt.title("A) Matriz en escala de grises (5x5)")
plt.colorbar(label="Intensidad")
plt.axis("off")
plt.show()
```

**Comprueba y responde:**

1. ¿Qué dimensiones y tipo (`dtype`) imprime el programa?
2. ¿Qué valor tenía `gray[2,3]`? ¿Qué pasa si cambias `gray[0:2,0:2]` por otro rango?
3. Abre `A_grayscale.png`: ¿coincide lo que ves con los valores de la matriz?

---

## 3) Actividad B — Imagen *color* (BGR) como matriz 3D

Construye una imagen sintética pequeña para poder leer fácilmente los valores:

```python
# ---------- B1. Crear patrón de color BGR pequeño ----------
H, W = 6, 6
img_bgr = np.zeros((H, W, 3), dtype=np.uint8)

for i in range(H):
    for j in range(W):
        blue  = j * 40           # 0, 40, 80, ...
        green = i * 40           # 0, 40, 80, ...
        red   = (i + j) * 20     # 0, 20, 40, ...
        img_bgr[i, j] = (blue, green, red)  # ¡OJO: BGR en OpenCV!

print("img_bgr.shape:", img_bgr.shape)  # (6, 6, 3)
print("img_bgr.dtype:",  img_bgr.dtype) # uint8
print("Pixel (2,3) BGR:", img_bgr[2, 3])

# ---------- B2. Convertir a RGB para mostrar con matplotlib ----------
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

plt.figure()
plt.imshow(img_rgb)
plt.title("B) Imagen sintética en color (RGB para visualizar)")
plt.axis("off")
plt.show()

# ---------- B3. Separar canales y visualizar ----------
chan_b, chan_g, chan_r = cv2.split(img_bgr)

fig, axs = plt.subplots(1, 3, figsize=(10, 3))
axs[0].imshow(chan_b, cmap="gray"); axs[0].set_title("Canal B"); axs[0].axis("off")
axs[1].imshow(chan_g, cmap="gray"); axs[1].set_title("Canal G"); axs[1].axis("off")
axs[2].imshow(chan_r, cmap="gray"); axs[2].set_title("Canal R"); axs[2].axis("off")
plt.suptitle("B) Canales por separado (como matrices 2D)")
plt.show()

# ---------- B4. Recomponer y verificar ----------
recon_bgr = cv2.merge((chan_b, chan_g, chan_r))
print("¿Recompuesta igual a original?:", np.array_equal(img_bgr, recon_bgr))
```

**Comprueba y responde:**

1. ¿Qué valores obtienes en el píxel `(2,3)`? Escríbelos como **B,G,R**.
2. ¿Cómo se ve cada canal por separado? ¿Por qué el canal R aparece más claro en ciertos lugares?
3. ¿La imagen recompuesta coincide con la original?

---

## 4) Actividad C — Recorrer píxeles, filas, columnas y ROI

```python
# ---------- C1. Extraer una fila, una columna y una ROI ----------
fila2 = img_bgr[2, :, :]     # fila 2 completa (6 x 3)
col3  = img_bgr[:, 3, :]     # columna 3 completa (6 x 3)
roi   = img_bgr[1:4, 2:5, :] # submatriz de 3x3 píxeles (cada uno con 3 canales)

print("fila2.shape:", fila2.shape)
print("col3.shape:",  col3.shape)
print("roi.shape:",    roi.shape)

# Mostrar ROI ampliada para inspeccionar valores
roi_rgb = cv2.cvtColor(roi, cv2.COLOR_BGR2RGB)
plt.figure()
plt.imshow(cv2.resize(roi_rgb, (roi_rgb.shape[1]*80, roi_rgb.shape[0]*80), interpolation=cv2.INTER_NEAREST))
plt.title("C) ROI 3x3 (ampliada)")
plt.axis("off")
plt.show()
```

**Comprueba y responde:**

* Escribe los valores **B,G,R** de la ROI píxel a píxel (3x3). ¿Coinciden con el patrón que generaste?

---

## 5) Actividad D — Rejilla y etiquetas sobre los píxeles (anotación)

Esta función dibuja una **rejilla** y escribe sobre cada celda la coordenada `(fila,col)` y el valor **B,G,R** del píxel:

```python
def anotar_matriz_bgr(img_bgr, scale=80):
    h, w, _ = img_bgr.shape
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    grande  = cv2.resize(img_rgb, (w*scale, h*scale), interpolation=cv2.INTER_NEAREST)

    for i in range(h):
        for j in range(w):
            x1, y1 = j*scale, i*scale
            x2, y2 = (j+1)*scale, (i+1)*scale
            cv2.rectangle(grande, (x1, y1), (x2, y2), (0, 0, 0), 1)
            b, g, r = img_bgr[i, j].tolist()

            # Sombra + texto blanco para legibilidad
            cv2.putText(grande, f"({i},{j})", (x1+5, y1+22), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,0), 2)
            cv2.putText(grande, f"({i},{j})", (x1+5, y1+22), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255), 1)
            cv2.putText(grande, f"B:{b} G:{g} R:{r}", (x1+5, y1+45), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,0), 2)
            cv2.putText(grande, f"B:{b} G:{g} R:{r}", (x1+5, y1+45), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255), 1)

    plt.figure(figsize=(6,6))
    plt.imshow(grande)
    plt.title("D) Rejilla y valores por píxel")
    plt.axis("off")
    plt.show()

anotar_matriz_bgr(img_bgr, scale=80)
```

> **Tip:** Con esta visualización, el grupo **“ve” la matriz**: coordenadas, tripletes BGR y correspondencia visual.

---

## 6) Actividad E — Tipos de dato, rangos y saturación vs desbordamiento

```python
# ---------- E1. Rango en uint8 ----------
print("Tipo img_bgr:", img_bgr.dtype)  # uint8 -> 0..255

# ---------- E2. Normalizar a float32 [0..1] ----------
img_float = img_bgr.astype(np.float32) / 255.0
print("Pixel (2,3) float32:", img_float[2, 3])  # ahora ~[0..1]

# ---------- E3. Saturación (cv2.add) vs desbordamiento (+ de NumPy) ----------
a = np.array([[250]], dtype=np.uint8)
b = np.array([[ 10]], dtype=np.uint8)

sum_numpy = (a + b)[0, 0]     # desbordamiento modular -> 4 (porque 260 mod 256 = 4)
sum_cv2    = cv2.add(a, b)[0, 0]  # saturación -> 255

print("a + b con NumPy:", int(sum_numpy))
print("cv2.add(a, b):",   int(sum_cv2))
```

**Reflexiona y responde:**

* ¿Por qué `a + b` y `cv2.add(a, b)` dan resultados distintos en `uint8`?
* ¿Qué ventajas tiene convertir a `float32` antes de ciertas operaciones?

---

## 7) (Opcional) Cargar una imagen propia y repetir

Usa una imagen pequeña (o **redúcela**):

```python
# Cargar imagen propia (opcional)
img_bgr2 = cv2.imread("mi_imagen.jpg")  # reemplaza por tu archivo
if img_bgr2 is not None:
    # Redimensionar para inspección cómoda (p. ej. 16x16)
    img_small = cv2.resize(img_bgr2, (16, 16), interpolation=cv2.INTER_AREA)
    anotar_matriz_bgr(img_small, scale=40)
else:
    print("No se encontró mi_imagen.jpg (opcional).")
```

---

## Entregables del estudiante

1. **Script** `practica_1.py` (con todas las secciones A–E).
2. **Imágenes** generadas: `A_grayscale.png` y capturas de:

   * Canales B, G, R.
   * ROI ampliada.
   * Rejilla con etiquetas (D).
3. **Respuestas breves** (máx. 1 pág.) a las preguntas de cada actividad.

## Errores comunes (y cómo evitarlos)

* **Confundir RGB con BGR**: convierte a RGB para mostrar en Matplotlib.
* **Índices invertidos**: `img[fila, columna]` (no `x,y`).
* **Rangos**: en `uint8`, 256 ≡ 0 (desbordamiento). Para cálculos, usa `float32`.
* **Visualización**: si `cv2.imshow` da problemas, usa Matplotlib.

## Reto de extensión (opcional)

* **HSV**: convierte `img_bgr` a HSV, separa canales **H**, **S**, **V** y explica qué representa cada uno.

  ```python
  img_hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
  H, S, V = cv2.split(img_hsv)
  ```

---

### Checklist

* [ ] Leo y escribo imágenes con OpenCV.
* [ ] Distingo matrices 2D (grises) y 3D (color).
* [ ] Identifico orden de canales en OpenCV (BGR) y en Matplotlib (RGB).
* [ ] Separo y rearmo canales correctamente.
* [ ] Comprendo `uint8` vs `float32`, saturación y desbordamiento.

