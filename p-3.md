# Práctica — Clasificación de Figuras (X y Cuadrado) con Desvío por Servo en Banda Transportadora (Serial)

## 1) Objetivo general

Implementar un sistema de visión por computadora capaz de **clasificar en tiempo real dos figuras (X y cuadrado)** que avanzan sobre una banda transportadora, y **accionar un servomotor** como compuerta para **desviar** cada pieza al recipiente correspondiente, utilizando **comunicación Serial (USB)** entre PC y microcontrolador.

## 2) Competencias y resultados de aprendizaje

* Capturar video desde cámara y procesar imágenes (binarización, contornos, Transformada de Hough).
* Diseñar un clasificador geométrico simple (X vs. cuadrado) robusto a ruido básico.
* Integrar PC ↔ microcontrolador por **Serial** con un **protocolo mínimo**.
* Controlar un **servo** para realizar la acción de desvío y mantener una **banda** en movimiento constante.
* Medir desempeño con **matriz de confusión** y **tiempos de respuesta**.

## 3) Materiales y software

**Hardware**

* Banda transportadora casera (motor DC 6–12 V, rodillos).
* 1 × **Micro-servo** (SG90 o similar) para compuerta.
* 1 × **Arduino Uno** o **ESP32** (cualquiera funciona).
* 1 × **Driver** para motor DC (L298N/MX1508/Motor Shield), si se controla motor desde el micro.
* 1 × Fuente 5 V (servo) y 6–12 V (motor DC).
* 1 × **Cámara** (webcam USB).
* Figuras impresas en **negro sobre fondo blanco**: **X** y **□** en cartulina.

**Software (en la PC)**

* Opción Python:

  * Python 3.10+
  * Paquetes: `opencv-python`, `numpy`, `pyserial`
  * Editor sugerido: **VS Code**
* Opción MATLAB:

  * MATLAB con Image Processing Toolbox (preferible)
  * Soporte de cámara (`webcam`) y `serialport`

## 4) Topología del sistema

* Cámara fija con vista cenital de una sección de la banda (zona de decisión).
* La banda avanza a **velocidad constante**.
* El **servo** actúa como **compuerta desviadora** al final.
* La **PC** realiza la **detección y clasificación** y envía por **Serial** el comando:

  * `"X\n"` para figura X
  * `"Q\n"` para cuadrado
* El **microcontrolador** posiciona el servo a **Ángulo\_A** o **Ángulo\_B**, espera **\~600 ms** y vuelve a **centro**.

## 5) Conexiones eléctricas (referencia)

### 5.1 Servo (SG90)

* Señal (amarillo/naranja) → pin PWM del micro (Arduino D9, o ESP32 GPIO13).
* Vcc (rojo) → **5 V** estable (no tomar del USB si el servo se esfuerza).
* GND (marrón/negro) → GND del micro y GND de la fuente (tierras comunes).

### 5.2 Motor DC (opcional desde micro)

* Driver L298N/MX1508:

  * IN1/IN2 a pines digitales (definidos en firmware).
  * EN (enable) a PWM para velocidad (Arduino D5; ESP32 canal PWM).
  * VMotor (6–12 V) a fuente DC.
  * GND del driver común con GND del micro.

> **Seguridad:** fijar firmemente el servo/compuerta; evitar atrapamientos; no sobrecargar el 5 V del micro. Usar fuentes separadas para **servo** y **motor**, con **GND común**.

---

## 6) Flujo de visión y decisión (teoría mínima aplicada)

1. **Captura** de frame.
2. **Pre-procesamiento**: escala de grises → suavizado (GaussianBlur) → **binarización adaptativa** (robusta a sombras).
3. **ROI** (región horizontal) sobre la **línea de decisión** (y = constante).
4. **Detección de Cuadrado (□)**:

   * Contornos externos → aproximación poligonal (Douglas-Peucker).
   * Criterios: **4 vértices**, convexo, **relación de aspecto \~1**, área mínima.
5. **Detección de X**:

   * Bordes (Canny) en ROI → **HoughLinesP** → buscar **dos líneas aproximadamente perpendiculares** (≈90°).
6. **Antirrebote lógico (cooldown)** para no disparar múltiples veces por la misma pieza.
7. **Comando Serial** `"Q\n"` o `"X\n"` al microcontrolador.

---

## 7) Versión Python (OpenCV + PySerial)

### 7.1 Instalación

```bash
pip install opencv-python numpy pyserial
```

### 7.2 Código (PC)

> Ajustar `SERIAL_PORT` (Windows: `COM3`, macOS/Linux: `/dev/tty.usbmodem*` o `/dev/ttyUSB*`).
> Ajustar `DECISION_Y` a la geometría de la cámara.

```python
import cv2
import numpy as np
import serial
import time

SERIAL_PORT = "COM3"   # <- AJUSTAR
BAUD = 115200

ser = serial.Serial(SERIAL_PORT, BAUD, timeout=0.1)
time.sleep(2)  # espera reinicio del micro

cap = cv2.VideoCapture(0)  # probar índices; en macOS puede requerir CAP_AVFOUNDATION
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  1280)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)

DECISION_Y = 360   # línea horizontal de decisión
MARGIN = 30        # grosor de la banda de evaluación

def is_square(cnt):
    peri = cv2.arcLength(cnt, True)
    approx = cv2.approxPolyDP(cnt, 0.04 * peri, True)
    if len(approx) == 4 and cv2.isContourConvex(approx):
        x,y,w,h = cv2.boundingRect(approx)
        ratio = w / float(h)
        return 0.80 < ratio < 1.20 and cv2.contourArea(cnt) > 2000
    return False

def is_X(mask_roi):
    edges = cv2.Canny(mask_roi, 60, 150)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=50, minLineLength=30, maxLineGap=10)
    if lines is None or len(lines) < 2:
        return False
    angles = []
    for l in lines:
        x1,y1,x2,y2 = l[0]
        ang = np.degrees(np.arctan2(y2 - y1, x2 - x1))
        angles.append(ang)
    # ¿dos líneas ~perpendiculares?
    for i in range(len(angles)):
        for j in range(i+1, len(angles)):
            diff = abs((angles[i] - angles[j] + 180) % 180 - 90)
            if diff < 20:
                return True
    return False

def classify(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5,5), 0)
    th = cv2.adaptiveThreshold(blur, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY_INV, 41, 10)

    h, w = th.shape
    y1, y2 = max(0, DECISION_Y - MARGIN), min(h, DECISION_Y + MARGIN)
    roi = th[y1:y2, :]

    cnts, _ = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    label = None

    # Cuadrado primero
    for c in cnts:
        c_full = c + [0, y1]
        if is_square(c_full):
            label = "Q"
            cv2.drawContours(frame, [c_full], -1, (0,255,0), 2)
            break

    # Si no cuadrado, buscar X
    if label is None and is_X(roi):
        label = "X"
        cv2.rectangle(frame, (0,y1), (w,y2), (255,0,255), 2)

    # Línea de decisión
    cv2.line(frame, (0, DECISION_Y), (w, DECISION_Y), (0,255,255), 2)
    return label, frame

cooldown_until = 0.0

while True:
    ok, frame = cap.read()
    if not ok:
        break

    label, vis = classify(frame)
    now = time.time()

    if label and now > cooldown_until:
        ser.write((label + "\n").encode("utf-8"))
        print("TX:", label)
        cooldown_until = now + 0.8  # evita múltiples disparos

    cv2.putText(vis, f"Ultima clase: {label or '-'}", (20,40),
                cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)
    cv2.imshow("Clasificador X / Cuadrado", vis)
    if cv2.waitKey(1) & 0xFF == 27:  # ESC
        break

cap.release()
ser.close()
cv2.destroyAllWindows()
```

---

## 8) Versión MATLAB (Image Processing + Serial)

### 8.1 Puntos clave

* `webcam` para capturar.
* Pre-proceso: `rgb2gray` → `imgaussfilt` → `adaptthresh` + `imbinarize` → `imcomplement`.
* Cuadrado: `bwboundaries` + `reducepoly` (o `regionprops` con solidez y bounding box).
* X: `edge` + `hough`/`houghpeaks`/`houghlines`, buscar dos líneas \~perpendiculares.

### 8.2 Código (PC)

> Ajustar `port` y `cam` según equipo.

```matlab
% --- Serial ---
port = "COM3"; baud = 115200;
s = serialport(port, baud);
configureTerminator(s, "LF");

% --- Cámara ---
cam = webcam(1);          % ajustar índice
cam.Resolution = '1280x720';

DECISION_Y = 360;
MARGIN = 30;
cooldownUntil = 0;

hFig = figure('Name','Clasificador X / Cuadrado','NumberTitle','off');

while ishandle(hFig)
    frame = snapshot(cam);
    gray  = rgb2gray(frame);
    blur  = imgaussfilt(gray, 1.0);
    T     = adaptthresh(blur, 0.5, 'NeighborhoodSize', 41, 'Statistic', 'gaussian');
    bw    = imbinarize(blur, T);
    bw    = imcomplement(bw);
    bw    = bwareaopen(bw, 500);

    [H, W] = size(bw);
    y1 = max(1, DECISION_Y - MARGIN); y2 = min(H, DECISION_Y + MARGIN);
    roi = bw(y1:y2, :);

    label = '';

    % --- Cuadrado por contorno + poligonal ---
    B = bwboundaries(roi, 'noholes');
    foundSquare = false;
    for k = 1:numel(B)
        cnt = B{k};
        if size(cnt,1) < 30, continue; end
        poly = reducepoly(cnt, 2); % tolerancia
        if size(poly,1) == 5 % 4 vértices + cierre
            x = poly(:,2); y = poly(:,1) + y1 - 1;
            bb = [min(x) min(y) max(x)-min(x) max(y)-min(y)];
            ratio = bb(3)/bb(4);
            areaOK = polyarea(x(1:end-1), y(1:end-1)) > 2000;
            if ratio > 0.8 && ratio < 1.2 && areaOK
                foundSquare = true;
                label = 'Q';
                frame = insertShape(frame, 'Polygon', [x(1:end-1)'; y(1:end-1)']', ...
                                    'LineWidth', 3, 'Color','green');
                break
            end
        end
    end

    % --- X por Hough si no hubo cuadrado ---
    if ~foundSquare
        edges = edge(roi, 'Canny', [0.15 0.4]);
        [Hh,Th,Rr] = hough(edges);
        P  = houghpeaks(Hh, 6, 'Threshold', ceil(0.3*max(Hh(:))));
        lines = houghlines(edges, Th, Rr, P, 'FillGap', 10, 'MinLength', 30);
        if numel(lines) >= 2
            angs = arrayfun(@(L) atan2d((L.point2(2)-L.point1(2)), (L.point2(1)-L.point1(1))), lines);
            ok = false;
            for i=1:numel(angs)
                for j=i+1:numel(angs)
                    diff = abs(mod(angs(i)-angs(j)+180,180)-90);
                    if diff < 20, ok = true; break; end
                end
                if ok, break; end
            end
            if ok
                label = 'X';
                frame = insertShape(frame,'Rectangle',[1 y1 size(frame,2) y2-y1], ...
                                    'LineWidth', 3, 'Color','magenta');
            end
        end
    end

    % Línea de decisión y texto
    frame = insertShape(frame, 'Line', [1 DECISION_Y size(frame,2) DECISION_Y], ...
                        'LineWidth', 2, 'Color','yellow');
    frame = insertText(frame, [20 20], sprintf('Ultima clase: %s', label), ...
                       'FontSize', 22, 'BoxColor','black', 'TextColor','white');

    imshow(frame); drawnow;

    % Envío serial con cooldown (~0.8 s)
    if ~isempty(label) && (seconds(datetime('now') - datetime(0,'ConvertFrom','posixtime')) > cooldownUntil)
        writeline(s, label);
        cooldownUntil = seconds(datetime('now') - datetime(0,'ConvertFrom','posixtime')) + 0.8;
    end

    if ~ishandle(hFig), break; end
end

clear cam s
```

---

## 9) Firmware del microcontrolador (elige UNO u ESP32)

### 9.1 Arduino Uno

* Pins sugeridos: Servo en **D9**. Motor DC: **D6/D7** (dirección), **D5** (PWM Enable).

```cpp
#include <Servo.h>

Servo gate;
const int SERVO_PIN = 9;

// Motor DC opcional:
const int MOTOR_EN = 5;   // PWM
const int MOTOR_IN1 = 6;
const int MOTOR_IN2 = 7;

const int ANGLE_CENTER = 90;
const int ANGLE_Q = 45;   // Cuadrado
const int ANGLE_X = 135;  // X
const unsigned long PULSE_MS = 600;

void setup() {
  Serial.begin(115200);
  gate.attach(SERVO_PIN);
  gate.write(ANGLE_CENTER);

  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(MOTOR_EN, OUTPUT);

  // Banda adelante ~70%
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  analogWrite(MOTOR_EN, 180);
}

void pulseTo(int angle) {
  gate.write(angle);
  delay(PULSE_MS);
  gate.write(ANGLE_CENTER);
}

void loop() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    if (cmd == "Q")      pulseTo(ANGLE_Q);
    else if (cmd == "X") pulseTo(ANGLE_X);
  }
}
```

### 9.2 ESP32 (Arduino core)

* Pins sugeridos: Servo en **GPIO13**. Motor DC: **IN1=26, IN2=27, EN=25 (PWM canal 0)**.

```cpp
#include <ESP32Servo.h>
Servo gate;

const int SERVO_PIN = 13;

const int MOTOR_EN = 25;  // PWM canal 0
const int MOTOR_IN1 = 26;
const int MOTOR_IN2 = 27;

const int ANGLE_CENTER = 90;
const int ANGLE_Q = 45;
const int ANGLE_X = 135;
const unsigned long PULSE_MS = 600;

void setup() {
  Serial.begin(115200);
  gate.setPeriodHertz(50);
  gate.attach(SERVO_PIN, 500, 2400);
  gate.write(ANGLE_CENTER);

  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  ledcSetup(0, 20000, 8);
  ledcAttachPin(MOTOR_EN, 0);

  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  ledcWrite(0, 180); // ~70%
}

void pulseTo(int angle) {
  gate.write(angle);
  delay(PULSE_MS);
  gate.write(ANGLE_CENTER);
}

void loop() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    if (cmd == "Q")      pulseTo(ANGLE_Q);
    else if (cmd == "X") pulseTo(ANGLE_X);
  }
}
```

---

## 10) Procedimiento paso a paso (para los alumnos)

1. **Montaje mecánico**

   * Colocar la cámara en vista cenital de la zona de decisión.
   * Instalar la compuerta (servo) al final de la banda; definir **izquierda = Q**, **derecha = X** (o viceversa).
2. **Cableado**

   * Servo al pin indicado y 5 V estable; GND común con el micro y con el driver de motor.
   * Motor DC al driver; driver a fuente y al micro (IN1/IN2/EN).
3. **Cargar firmware**

   * Subir el sketch según sea **Arduino Uno** o **ESP32**.
4. **Probar motor y servo**

   * Con el firmware cargado, confirmar que la banda gire y el servo esté en **centro**.
5. **Probar Serial**

   * Desde el **Monitor Serial** enviar “Q” y “X” (con salto de línea) y observar el servo.
6. **Configurar PC**

   * Instalar dependencias (Python) **o** preparar MATLAB.
   * En el script de PC, **ajustar**: `SERIAL_PORT` y `DECISION_Y`.
7. **Calibración de visión**

   * Colocar una **cartulina blanca** como fondo.
   * Ajustar altura de cámara y `MARGIN` para que la figura cruce claramente la ROI.
   * Verificar detección: contorno verde para **□**, rectángulo magenta para **X**.
8. **Prueba integral**

   * Hacer pasar **10 X** y **10 □** mezcladas.
   * Registrar aciertos/errores y llenar la **matriz de confusión**.
9. **Ajustes finos**

   * Si hay falsos positivos, ajustar: tamaño mínimo de contorno, tolerancia poligonal, umbrales de Canny/Hough, ratio de aspecto.

---

## 11) Solución de problemas (FAQ)

* **La cámara no abre (índice 0).** Probar `1`, `2`; en macOS puede requerir `cv2.CAP_AVFOUNDATION`.
* **Puerto Serial no aparece.** Verificar driver/placa; cerrar otros programas que lo usen; confirmar velocidad 115200.
* **Servo vibra o se calienta.** Fuente 5 V insuficiente; usar fuente dedicada y GND común.
* **Dispara varias veces por pieza.** Incrementar `cooldown` (0.8–1.2 s) o acortar ROI.
* **No detecta la X.** Aumentar contraste, engrosar la X impresa, relajar ángulo de perpendicularidad (±25°), bajar/ajustar umbrales de Canny.
* **Confunde rombos con cuadrados.** Ajustar ratio (0.9–1.1) o verificar ángulos internos (\~90°) si se desea mayor rigor.

---

## 12) Extensiones (opcionales para equipos rápidos)

* Tercera clase: **círculo** (HoughCircles o circularidad por $4\pi A / P^2$).
* Ajuste dinámico de **PWM** del motor según congestión en la ROI.
* Registro de **timestamps** para medir latencia visión→servo.

