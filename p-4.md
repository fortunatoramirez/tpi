
# Práctica 4 — Detección y Seguimiento por Color en Banda Transportadora (Python + OpenCV)

## Objetivo

Desarrollar un sistema que **detecte en tiempo real colores específicos** (p. ej., rojo, verde, azul, amarillo) en objetos que se desplazan sobre la banda y **resalte cuál es el “siguiente en caer”** (el más cercano al final de la banda). Se trabajará en **equipos**, cada uno responsable de **calibrar** y **evaluar** un color y su desempeño.

---

## Marco teórico

### 1) ¿Por qué HSV y no RGB?

* **RGB** mezcla intensidad y color; cambios de luz afectan mucho los umbrales.
* **HSV** separa **Tono (H)**, **Saturación (S)** e **Intensidad/Valor (V)**:

  * **H** define el color (rojo, verde, etc.).
  * **S** qué tan “puro” es (sin/with gris).
  * **V** brillo (iluminación).
* En visión en tiempo real con iluminación variable, **threshold en HSV** es más **estable**.

### 2) Segmentación por color (inRange)

1. Convertir BGR → HSV.
2. Definir **rangos** (mín–máx) por color:

   * Azul, Verde, Amarillo: **un rango** continuo de H.
   * **Rojo** es especial: el tono cruza el 0°, así que se usa **DOS rangos** (altos y bajos).
3. Crear **máscara** binaria con `cv2.inRange(hsv, low, high)`.

### 3) Limpieza y contornos

* Aplicar **morfología**: `erode` (quita ruido) + `dilate` (recupera forma) → “opening”.
* `findContours` para obtener blobs; filtrar por **área mínima**.
* Calcular **centroide** (momentos) y **bounding box**.

### 4) “Siguiente en caer”

* Definir el **borde de salida** (cerca del final de la banda, eje *y* grande).
* Para cada objeto detectado, calcular **distancia vertical** al borde inferior `dist = y_salida - cy`.
* El **mínimo dist** (positivo) es el **siguiente en caer**; resáltalo (marco/etiqueta).

### 5) Ajustes típicos (checklist)

* **Iluminación**: fondo uniforme (cartulina blanca), evitar reflejos.
* **H, S, V**:

  * Subir **S** mínima cuando el color se “lava” por luz.
  * Ajustar **V** mínima para evitar sombras.
* **Área mínima**: subir si hay granulado; bajar si los objetos son pequeños.
* **Blur** suave (Gaussian blur 3×3 o 5×5) reduce ruido antes del umbral.
* **ROI**: puedes analizar sólo una franja superior o inferior para ganar estabilidad/velocidad.
* **Balance/autoexposición** (si la cámara lo permite): fijar exposición para que no cambie entre frames.

---

## Implementación (Python)

> Dependencias: `pip install opencv-python numpy`

* El código trae **rangos iniciales** (aprox.). Cada equipo **ajustará su color**.
* Maneja **rojo con dos rangos**.
* Calcula el **“siguiente en caer”** respecto al **borde inferior** (puedes mover la línea de salida).

```python
import cv2
import numpy as np

# --- Config de cámara ---
CAM_INDEX = 0   # cambia a 1 si usas la segunda cámara
W, H = 1280, 720

# --- Línea de salida (al final de la banda) ---
EXIT_Y = int(H * 0.88)   # ~88% de la altura; ajusta según tu montaje
AREA_MIN = 900           # píxeles; ajusta según tamaño del objeto

# --- Rangos HSV INICIALES (ajustar!) ---
# Nota: H [0..179], S [0..255], V [0..255]
COLOR_RANGES = {
    # Rojo envuelve el 0°, se usan dos rangos y luego se combinan
    "rojo_1":  (np.array([0, 120, 70]),   np.array([10, 255, 255])),
    "rojo_2":  (np.array([170, 120, 70]), np.array([179, 255, 255])),
    "azul":    (np.array([100, 120, 70]), np.array([140, 255, 255])),
    "verde":   (np.array([40,  80,  60]), np.array([80,  255, 255])),
    "amarillo":(np.array([20, 120, 80]),  np.array([32,  255, 255]))
}

# Habilita/inhabilita colores a seguir
ACTIVE_COLORS = ["rojo", "azul", "verde", "amarillo"]  # puedes dejar menos

# --- Utilidades ---
def get_color_mask(hsv, color_name):
    if color_name == "rojo":
        m1 = cv2.inRange(hsv, *COLOR_RANGES["rojo_1"])
        m2 = cv2.inRange(hsv, *COLOR_RANGES["rojo_2"])
        mask = cv2.bitwise_or(m1, m2)
    else:
        low, high = COLOR_RANGES[color_name]
        mask = cv2.inRange(hsv, low, high)
    # limpieza morfológica
    kernel = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
    mask = cv2.dilate(mask, kernel, iterations=1)
    return mask

def find_objects_by_color(frame, hsv):
    """Devuelve lista de dicts: {'color', 'cnt', 'cx', 'cy', 'bbox'}"""
    objs = []
    for cname in ACTIVE_COLORS:
        mask = get_color_mask(hsv, "rojo" if cname=="rojo" else cname)
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            area = cv2.contourArea(c)
            if area < AREA_MIN:
                continue
            x,y,w,h = cv2.boundingRect(c)
            M = cv2.moments(c)
            if M["m00"] == 0: 
                continue
            cx = int(M["m10"]/M["m00"])
            cy = int(M["m01"]/M["m00"])
            objs.append({"color": cname, "cnt": c, "cx": cx, "cy": cy, "bbox": (x,y,w,h)})
    return objs

def draw_scene(frame, objs, next_obj):
    # línea de salida
    cv2.line(frame, (0, EXIT_Y), (W, EXIT_Y), (0,255,255), 2)

    # dibuja cada objeto
    for o in objs:
        x,y,w,h = o["bbox"]
        cv2.rectangle(frame, (x,y), (x+w,y+h), (0,255,0), 2)
        cv2.circle(frame, (o["cx"], o["cy"]), 5, (255,255,255), -1)
        cv2.putText(frame, o["color"], (x, max(y-8, 0)),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,255), 2)

    # resalta el siguiente en caer
    if next_obj is not None:
        x,y,w,h = next_obj["bbox"]
        cv2.rectangle(frame, (x,y), (x+w,y+h), (0,0,0), 3)
        cv2.putText(frame, f"SIGUE: {next_obj['color']}", (20,40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,0,0), 3)
        cv2.putText(frame, f"SIGUE: {next_obj['color']}", (20,40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255,255,255), 2)

def pick_next_to_fall(objs):
    """Selecciona el objeto con menor distancia positiva a EXIT_Y."""
    best = None
    best_dist = 1e9
    for o in objs:
        dist = EXIT_Y - o["cy"]
        if 0 < dist < best_dist:
            best = o
            best_dist = dist
    return best

# --- Main ---
cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  W)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, H)

if not cap.isOpened():
    print("No se pudo abrir la cámara. Cambia CAM_INDEX.")
    raise SystemExit

while True:
    ok, frame = cap.read()
    if not ok:
        break

    # Pre-proceso
    blur = cv2.GaussianBlur(frame, (5,5), 0)
    hsv  = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)

    objs = find_objects_by_color(frame, hsv)
    next_obj = pick_next_to_fall(objs)
    draw_scene(frame, objs, next_obj)

    cv2.imshow("Color Tracker en Banda", frame)
    if cv2.waitKey(1) & 0xFF == 27:  # ESC para salir
        break

cap.release()
cv2.destroyAllWindows()
```

### Dónde ajustar (rápido):

* **`EXIT_Y`**: posición de la línea de salida (según tu montaje).
* **`AREA_MIN`**: filtra ruido o acepta piezas pequeñas.
* **`COLOR_RANGES`**: **cada equipo** calibra H/S/V para su color.
* **Iluminación**: si hay parpadeos, fija exposición de cámara o pon una lámpara difusa.

> Sugerencia: imprime en la terminal los rangos que terminan usando y guárdalos para la siguiente sesión.

---

## Plan de trabajo por equipos


### Roles/colores (3–4 equipos)

* **Equipo A — Azul**: calibra HSV y documenta sensibilidad a luz.
* **Equipo B — Verde**: calibra y optimiza morfología (kernel, iterations).
* **Equipo C — Rojo**: calibra con **dos rangos** y valida que no se mezclen naranjas/rosas.
* **Equipo D — Amarillo** (opcional): calibra y prueba con objetos similares en brillo.

### Entregables

1. **Rangos HSV finales** por equipo y explicación de por qué funcionan.
2. **Video corto o screenshot** mostrando al **“siguiente en caer”** destacado.
3. **Tabla rápida (10 piezas)**: predicción vs. color real → % de aciertos.
4. **Tip práctico** aprendido (p. ej. “subir Smin a 120 cuando hay brillantez”).

### “Retos exprés” 

* +1 punto extra si su detección aguanta **doble velocidad** de banda.
* +1 si su modelo **no confunde** caramelos pegados (proponen una regla: área máximo o separación por erosión adicional).
* +1 si integran **ROI** sólo cerca del final de la banda (más FPS y menos falsos).

---

## Notas de campo / Problemas comunes

* **Brillos en envoltura**: bajan S (se vuelve grisáceo) → sube `Smin` y/o **apaga reflejos** con una hoja difusora.
* **Sombras**: sube `Vmin` o ilumina mejor.
* **Falsos positivos por fondo**: coloca **cartulina blanca** y aleja colores parecidos del entorno.
* **Motion blur**: más luz para permitir **exposición más corta**; baja ganancia automática.
