
# Práctica 4 — Detección y Seguimiento por Color en Banda Transportadora (Python + OpenCV)

## Objetivo

Desarrollar un sistema que **detecte en tiempo real colores específicos** (p. ej., rojo, verde, azul, amarillo) en objetos que se desplazan sobre la banda y **resalte cuál es el “siguiente en caer”** (el más cercano al final de la banda). Se trabajará en **equipos**, cada uno responsable de **calibrar** y **evaluar** un color y su desempeño.

---

## Marco teórico

### 1) ¿Por qué HSV y no RGB?

* **RGB** mezcla intensidad y color; cambios de luz afectan mucho los umbrales.
* **HSV** separa **Tono (H)**, **Saturación (S)** e **Intensidad/Valor (V)**:

  * **H** define el color (rojo, verde, etc.).
  * **S** qué tan “puro” es (sin/with gris).
  * **V** brillo (iluminación).
* En visión en tiempo real con iluminación variable, **threshold en HSV** es más **estable**.

### 2) Segmentación por color (inRange)

1. Convertir BGR → HSV.
2. Definir **rangos** (mín–máx) por color:

   * Azul, Verde, Amarillo: **un rango** continuo de H.
   * **Rojo** es especial: el tono cruza el 0°, así que se usa **DOS rangos** (altos y bajos).
3. Crear **máscara** binaria con `cv2.inRange(hsv, low, high)`.

### 3) Limpieza y contornos

* Aplicar **morfología**: `erode` (quita ruido) + `dilate` (recupera forma) → “opening”.
* `findContours` para obtener blobs; filtrar por **área mínima**.
* Calcular **centroide** (momentos) y **bounding box**.

### 4) “Siguiente en caer”

* Definir el **borde de salida** (cerca del final de la banda, eje *y* grande).
* Para cada objeto detectado, calcular **distancia vertical** al borde inferior `dist = y_salida - cy`.
* El **mínimo dist** (positivo) es el **siguiente en caer**; resáltalo (marco/etiqueta).

### 5) Ajustes típicos (checklist)

* **Iluminación**: fondo uniforme (cartulina blanca), evitar reflejos.
* **H, S, V**:

  * Subir **S** mínima cuando el color se “lava” por luz.
  * Ajustar **V** mínima para evitar sombras.
* **Área mínima**: subir si hay granulado; bajar si los objetos son pequeños.
* **Blur** suave (Gaussian blur 3×3 o 5×5) reduce ruido antes del umbral.
* **ROI**: puedes analizar sólo una franja superior o inferior para ganar estabilidad/velocidad.
* **Balance/autoexposición** (si la cámara lo permite): fijar exposición para que no cambie entre frames.

---

## Implementación (Python)

> Dependencias: `pip install opencv-python numpy`

* El código trae **rangos iniciales** (aprox.). Cada equipo **ajustará su color**.
* Maneja **rojo con dos rangos**.
* Calcula el **“siguiente en caer”** respecto al **borde inferior** (puedes mover la línea de salida).

```python
import cv2
import numpy as np

# --- Cámara ---
CAM_INDEX = 0
TARGET_W, TARGET_H = 1280, 720

# --- Modo de salida: "down" (abajo) o "right" (derecha) ---
EXIT_MODE = "down"        # valor inicial: "down" o "right"
EXIT_POS_FRAC = 0.88      # posición relativa de la línea de salida (0..1)
AREA_MIN = 900            # píxeles mínimos para ignorar ruido

# --- Rangos HSV INICIALES (ajustar con tu iluminación) ---
COLOR_RANGES = {
    "rojo_1":   (np.array([0,   120, 70]),  np.array([10, 255, 255])),
    "rojo_2":   (np.array([170, 120, 70]),  np.array([179,255, 255])),
    "azul":     (np.array([100, 120, 70]),  np.array([140,255, 255])),
    "verde":    (np.array([40,   80, 60]),  np.array([80, 255, 255])),
    "amarillo": (np.array([20,  120, 80]),  np.array([32, 255, 255])),
}
ACTIVE_COLORS = ["rojo", "azul", "verde", "amarillo"]  # activa solo los que uses

# --- Utilidades de color/máscara ---
def get_color_mask(hsv, cname):
    if cname == "rojo":
        m1 = cv2.inRange(hsv, *COLOR_RANGES["rojo_1"])
        m2 = cv2.inRange(hsv, *COLOR_RANGES["rojo_2"])
        mask = cv2.bitwise_or(m1, m2)
    else:
        low, high = COLOR_RANGES[cname]
        mask = cv2.inRange(hsv, low, high)

    kernel = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
    mask = cv2.dilate(mask, kernel, iterations=1)
    return mask

def find_objects_by_color(hsv, area_min=AREA_MIN):
    objs = []
    for cname in ACTIVE_COLORS:
        mask = get_color_mask(hsv, cname)
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            area = cv2.contourArea(c)
            if area < area_min:
                continue
            x,y,w,h = cv2.boundingRect(c)
            M = cv2.moments(c)
            if M["m00"] == 0: 
                continue
            cx = int(M["m10"]/M["m00"])
            cy = int(M["m01"]/M["m00"])
            objs.append({"color": cname, "cnt": c, "cx": cx, "cy": cy, "bbox": (x,y,w,h)})
    return objs

def pick_next_to_fall(objs, exit_mode, exit_pos):
    """Elige el objeto con menor distancia POSITIVA hacia la línea de salida."""
    best = None
    best_dist = 1e9
    for o in objs:
        if exit_mode == "down":
            dist = exit_pos - o["cy"]
        else:  # "right"
            dist = exit_pos - o["cx"]
        if 0 < dist < best_dist:
            best = o
            best_dist = dist
    return best

def draw_scene(frame, objs, next_obj, exit_mode, exit_pos):
    H, W = frame.shape[:2]

    # Línea de salida
    if exit_mode == "down":
        cv2.line(frame, (0, exit_pos), (W, exit_pos), (0,255,255), 2)
    else:
        cv2.line(frame, (exit_pos, 0), (exit_pos, H), (0,255,255), 2)

    # Dibuja todos los objetos detectados
    for o in objs:
        x,y,w,h = o["bbox"]
        cv2.rectangle(frame, (x,y), (x+w,y+h), (0,255,0), 2)
        cv2.circle(frame, (o["cx"], o["cy"]), 5, (255,255,255), -1)
        cv2.putText(frame, o["color"], (x, max(y-8, 0)), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,255), 2)

    # Resalta el “siguiente en caer”
    if next_obj is not None:
        x,y,w,h = next_obj["bbox"]
        cv2.rectangle(frame, (x,y), (x+w,y+h), (0,0,0), 3)
        cv2.putText(frame, f"SIGUE: {next_obj['color']}", (20,40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,0,0), 3)
        cv2.putText(frame, f"SIGUE: {next_obj['color']}", (20,40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255,255,255), 2)

    # HUD con modo y ayuda
    cv2.putText(frame, f"EXIT: {exit_mode.upper()}  ([/]: mover linea)", (20,70),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,0), 3)
    cv2.putText(frame, f"EXIT: {exit_mode.upper()}  ([/]: mover linea)", (20,70),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,255), 2)

# --- Main ---
cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  TARGET_W)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, TARGET_H)

if not cap.isOpened():
    print("No se pudo abrir la cámara. Cambia CAM_INDEX.")
    raise SystemExit

while True:
    ok, frame = cap.read()
    if not ok:
        break

    H, W = frame.shape[:2]
    # posición de la línea de salida según el modo actual
    exit_pos = int((H if EXIT_MODE == "down" else W) * EXIT_POS_FRAC)

    blur = cv2.GaussianBlur(frame, (5,5), 0)
    hsv  = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)

    objs = find_objects_by_color(hsv, AREA_MIN)
    next_obj = pick_next_to_fall(objs, EXIT_MODE, exit_pos)
    draw_scene(frame, objs, next_obj, EXIT_MODE, exit_pos)

    cv2.imshow("Color Tracker en Banda", frame)
    key = cv2.waitKey(1) & 0xFF

    if key == 27:  # ESC
        break
    elif key == ord('d'):   # salida hacia abajo
        EXIT_MODE = "down"
    elif key == ord('r'):   # salida hacia la derecha
        EXIT_MODE = "right"
    elif key == ord('['):   # mueve línea de salida "hacia adentro"
        EXIT_POS_FRAC = max(0.50, EXIT_POS_FRAC - 0.02)
    elif key == ord(']'):   # mueve línea de salida "hacia afuera"
        EXIT_POS_FRAC = min(0.98, EXIT_POS_FRAC + 0.02)

cap.release()
cv2.destroyAllWindows()

```

### Dónde ajustar (rápido):

* **`EXIT_Y`**: posición de la línea de salida (según tu montaje).
* **`AREA_MIN`**: filtra ruido o acepta piezas pequeñas.
* **`COLOR_RANGES`**: **cada equipo** calibra H/S/V para su color.
* **Iluminación**: si hay parpadeos, fija exposición de cámara o pon una lámpara difusa.

> Sugerencia: imprime en la terminal los rangos que terminan usando y guárdalos para la siguiente sesión.

---

## Plan de trabajo por equipos


### Roles/colores (3–4 equipos)

* **Equipo A — Azul**: calibra HSV y documenta sensibilidad a luz.
* **Equipo B — Verde**: calibra y optimiza morfología (kernel, iterations).
* **Equipo C — Rojo**: calibra con **dos rangos** y valida que no se mezclen naranjas/rosas.
* **Equipo D — Amarillo** (opcional): calibra y prueba con objetos similares en brillo.

### Entregables

1. **Rangos HSV finales** por equipo y explicación de por qué funcionan.
2. **Video corto o screenshot** mostrando al **“siguiente en caer”** destacado.
3. **Tabla rápida (10 piezas)**: predicción vs. color real → % de aciertos.
4. **Tip práctico** aprendido (p. ej. “subir Smin a 120 cuando hay brillantez”).

### “Retos exprés” 

* +1 punto extra si su detección aguanta **doble velocidad** de banda.
* +1 si su modelo **no confunde** caramelos pegados (proponen una regla: área máximo o separación por erosión adicional).
* +1 si integran **ROI** sólo cerca del final de la banda (más FPS y menos falsos).

---

## Notas de campo / Problemas comunes

* **Brillos en envoltura**: bajan S (se vuelve grisáceo) → sube `Smin` y/o **apaga reflejos** con una hoja difusora.
* **Sombras**: sube `Vmin` o ilumina mejor.
* **Falsos positivos por fondo**: coloca **cartulina blanca** y aleja colores parecidos del entorno.
* **Motion blur**: más luz para permitir **exposición más corta**; baja ganancia automática.
