
# Práctica 5 — Clasificación por color con **recipiente giratorio**

## 1) Objetivo

Integrar la detección por color en Python (OpenCV) con el control de un **servo** mediante **Serial**, para que el plato/vaso dividido en cuatro secciones **se alinee al color** del M&M que está **a punto de caer**.

---

## 2) Competencias

* Segmentación por color en **HSV** (OpenCV).
* Selección del **“siguiente en caer”** con una línea de **pre-disparo**.
* Comunicación **PC → microcontrolador** por **Serial**.
* Posicionamiento **básico** de un **servo** con **ángulos fijos por color**.

---

## 3) Materiales y software

**Hardware**

* 1 banda transportadora (la existente).
* 1 cámara (webcam).
* 1 microcontrolador: **Arduino Uno** o **ESP32**.
* 1 servo estándar (SG90 / similar).
* 1 vaso de cartón dividido en **4** (R / G / B / Y) y eje simple (pegado al horn del servo).
* Cables Dupont.

**Software**

* **Python 3** con `opencv-python`, `numpy`, `pyserial`.
* **VS Code** (recomendado).
* **Arduino IDE** (o PlatformIO) para cargar el firmware.

---

## 4) Esquema del sistema 

* **PC (Python)**: Detecta por color → decide **color del siguiente en caer** → envía `'R'`, `'G'`, `'B'` o `'Y'` por **Serial** cuando cruza la línea de **pre-disparo**.
* **Micro (UNO/ESP32)**: Lee el carácter y **mueve el servo** a **un ángulo fijo** por color (p. ej. `R=0°, G=60°, B=120°, Y=180°`).

> Nota: En esta práctica **no usamos fuente externa** para el servo (el vaso es ligero). Si el servo tiembla: reduzcan ángulos o el tiempo de asentamiento.

---

## 5) Procedimiento (paso a paso)

1. **Montaje rápido**

   * Colocar la cámara en vista adecuada.
   * Fijar el vaso al **horn** del servo (que quede centrado con la caída).
   * Conectar **Señal→ D9 (UNO)** o **GPIO13 (ESP32)**; Vcc servo → **5V**; GND servo → **GND** del micro.

2. **Cargar firmware del micro** (elige UNO o ESP32 más abajo).

3. **Configurar Python**

   * Instalar dependencias: `pip install opencv-python numpy pyserial`.
   * Ajustar en el script: **`SERIAL_PORT`** (COM en Windows, `/dev/...` en macOS/Linux).

4. **Calibrar visualmente**

   * Usar cartulina blanca debajo.
   * Ajustar rangos HSV si es necesario (azul ya está **H:80–140**).
   * Ajustar **`PRETRIGGER_FRAC`** si el plato llega tarde/temprano.

5. **Prueba integral**

   * Correr Python → ver “SIGUE: color”.
   * Confirmar que al cruzar la línea de **pre-disparo** se envía el color y el **servo gira** al ángulo correspondiente.

---

## 6) Código — PC (Python + OpenCV + Serial)

> Atajos: **d/r** cambian “salida” (abajo/derecha). **[ / ]** mueven la línea de salida. **ESC** para salir.

```python
import cv2
import numpy as np
import serial, time

# --- Cámara ---
CAM_INDEX = 0
TARGET_W, TARGET_H = 1280, 720

# --- Línea / Dirección de salida ---
EXIT_MODE = "down"      # "down" (abajo) o "right" (derecha)  -> tecla d/r
EXIT_POS_FRAC = 0.88    # 0..1 posición de la línea de salida -> teclas [ ]

# --- Envío serial ---
SERIAL_PORT = "COM3"    # AJUSTA según tu PC (Win: COMx, Mac/Linux: /dev/tty...)
BAUD = 115200
ser = serial.Serial(SERIAL_PORT, BAUD, timeout=0.05)
time.sleep(2)

# Enviar cuando el objeto pase esta línea de pre-disparo (da tiempo al servo)
PRETRIGGER_FRAC = 0.78   # 0..1 (ajústalo si la banda va más rápida)
COOLDOWN_S = 0.6
_last_sent_t = 0
_last_sent_color = None

# --- Filtros básicos ---
AREA_MIN = 900

# --- Rangos HSV (azul ajustado 80..140) ---
COLOR_RANGES = {
    "rojo_1":   (np.array([0,   120, 70]),  np.array([10, 255, 255])),
    "rojo_2":   (np.array([170, 120, 70]),  np.array([179,255, 255])),
    "azul":     (np.array([80,  120, 70]),  np.array([140,255, 255])),  # <- ajuste de clase
    "verde":    (np.array([40,   80, 60]),  np.array([80,  255, 255])),
    "amarillo": (np.array([20,  120, 80]),  np.array([32,  255, 255])),
}
ACTIVE_COLORS = ["rojo", "azul", "verde", "amarillo"]

def get_color_mask(hsv, cname):
    if cname == "rojo":
        m1 = cv2.inRange(hsv, *COLOR_RANGES["rojo_1"])
        m2 = cv2.inRange(hsv, *COLOR_RANGES["rojo_2"])
        mask = cv2.bitwise_or(m1, m2)
    else:
        low, high = COLOR_RANGES[cname]
        mask = cv2.inRange(hsv, low, high)
    k = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, iterations=1)
    mask = cv2.dilate(mask, k, iterations=1)
    return mask

def find_objects_by_color(hsv):
    objs = []
    for cname in ACTIVE_COLORS:
        mask = get_color_mask(hsv, cname)
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            if cv2.contourArea(c) < AREA_MIN: 
                continue
            x,y,w,h = cv2.boundingRect(c)
            M = cv2.moments(c)
            if M["m00"] == 0: 
                continue
            cx = int(M["m10"]/M["m00"]); cy = int(M["m01"]/M["m00"])
            objs.append({"color": cname, "bbox":(x,y,w,h), "cx":cx, "cy":cy})
    return objs

def pick_next_to_fall(objs, exit_mode, exit_pos):
    best, best_dist = None, 1e9
    for o in objs:
        dist = (exit_pos - o["cy"]) if exit_mode=="down" else (exit_pos - o["cx"])
        if 0 < dist < best_dist:
            best, best_dist = o, dist
    return best

def color_char(cname):
    return {'rojo':'R', 'verde':'G', 'azul':'B', 'amarillo':'Y'}.get(cname)

def maybe_send(next_obj, exit_mode, H, W):
    global _last_sent_t, _last_sent_color
    if next_obj is None: 
        return
    now = time.time()
    if now - _last_sent_t < COOLDOWN_S: 
        return
    crossed = next_obj['cy'] >= int(H*PRETRIGGER_FRAC) if exit_mode=="down" \
              else next_obj['cx'] >= int(W*PRETRIGGER_FRAC)
    if crossed:
        ch = color_char(next_obj['color'])
        if ch and ch != _last_sent_color:
            ser.write((ch+"\n").encode('utf-8'))
            print("TX:", ch)
            _last_sent_t = now
            _last_sent_color = ch

def draw_scene(frame, objs, next_obj, exit_mode, exit_pos):
    H, W = frame.shape[:2]
    # Línea de salida (amarillo)
    if exit_mode=="down": cv2.line(frame,(0,exit_pos),(W,exit_pos),(0,255,255),2)
    else:                 cv2.line(frame,(exit_pos,0),(exit_pos,H),(0,255,255),2)
    # Línea de pre-disparo (azul)
    pre = int((H if exit_mode=="down" else W)*PRETRIGGER_FRAC)
    if exit_mode=="down": cv2.line(frame,(0,pre),(W,pre),(255,0,0),1)
    else:                 cv2.line(frame,(pre,0),(pre,H),(255,0,0),1)

    for o in objs:
        x,y,w,h = o["bbox"]
        cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2)
        cv2.putText(frame,o["color"],(x,max(0,y-6)),cv2.FONT_HERSHEY_SIMPLEX,0.6,(255,255,255),2)
    if next_obj is not None:
        x,y,w,h = next_obj["bbox"]
        cv2.rectangle(frame,(x,y),(x+w,y+h),(0,0,0),3)
        cv2.putText(frame,f"SIGUE: {next_obj['color']}",(20,40),
                    cv2.FONT_HERSHEY_SIMPLEX,1,(255,255,255),2)

cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  TARGET_W)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, TARGET_H)

while True:
    ok, frame = cap.read()
    if not ok: break
    H, W = frame.shape[:2]
    exit_pos = int((H if EXIT_MODE=="down" else W)*EXIT_POS_FRAC)

    hsv = cv2.cvtColor(cv2.GaussianBlur(frame,(5,5),0), cv2.COLOR_BGR2HSV)
    objs = find_objects_by_color(hsv)
    nxt  = pick_next_to_fall(objs, EXIT_MODE, exit_pos)
    maybe_send(nxt, EXIT_MODE, H, W)
    draw_scene(frame, objs, nxt, EXIT_MODE, exit_pos)

    cv2.putText(frame,f"EXIT {EXIT_MODE.upper()}  ([/]: mover)  d/r cambio",(20,70),
                cv2.FONT_HERSHEY_SIMPLEX,0.6,(255,255,255),2)
    cv2.imshow("Color + Servo (simple)", frame)

    k = cv2.waitKey(1) & 0xFF
    if k==27: break
    elif k==ord('d'): EXIT_MODE="down"
    elif k==ord('r'): EXIT_MODE="right"
    elif k==ord('['): EXIT_POS_FRAC=max(0.50, EXIT_POS_FRAC-0.02)
    elif k==ord(']'): EXIT_POS_FRAC=min(0.98, EXIT_POS_FRAC+0.02)

cap.release()
ser.close()
cv2.destroyAllWindows()
```

---

## 7) Código — Microcontrolador (servo a 4 ángulos)

### a) Arduino UNO (D9)

```cpp
#include <Servo.h>
Servo plate;

const int SERVO_PIN = 9;
// Ángulos por color (ajusta según tu montaje)
const int ANG_R = 0;    // Rojo
const int ANG_G = 60;   // Verde
const int ANG_B = 120;  // Azul
const int ANG_Y = 180;  // Amarillo
const int SETTLE_MS = 250;

void setup() {
  Serial.begin(115200);
  plate.attach(SERVO_PIN);
  plate.write(ANG_R);   // posición inicial
}

void goToColor(char c){
  int ang = ANG_R;
  if (c=='G') ang = ANG_G;
  else if (c=='B') ang = ANG_B;
  else if (c=='Y') ang = ANG_Y;
  plate.write(ang);
  delay(SETTLE_MS);
}

void loop() {
  if (Serial.available()) {
    char c = Serial.read();
    if (c=='\n' || c=='\r') return;
    if (c=='R' || c=='G' || c=='B' || c=='Y') goToColor(c);
  }
}
```

### b) ESP32 (GPIO13)

```cpp
#include <ESP32Servo.h>
Servo plate;

const int SERVO_PIN = 13;
const int ANG_R = 0, ANG_G = 60, ANG_B = 120, ANG_Y = 180;
const int SETTLE_MS = 220;

void setup(){
  Serial.begin(115200);
  plate.setPeriodHertz(50);
  plate.attach(SERVO_PIN, 500, 2500); // pulso típico
  plate.write(ANG_R);
}

void goToColor(char c){
  int ang = (c=='G')?ANG_G : (c=='B')?ANG_B : (c=='Y')?ANG_Y : ANG_R;
  plate.write(ang);
  delay(SETTLE_MS);
}

void loop(){
  if (Serial.available()){
    char c = Serial.read();
    if (c=='\n' || c=='\r') return;
    if (c=='R'||c=='G'||c=='B'||c=='Y') goToColor(c);
  }
}
```

---

## 8) Prueba y medición (10 M&M’s por color)

1. Para **cada color**, pasar **10** M&M’s.
2. Registrar si el plato llegó a la división correcta a tiempo.
3. Completar una **tabla de aciertos** y anotar los parámetros usados.

**Tabla sugerida (por equipo):**

```
Color      Aciertos / 10   PRETRIGGER_FRAC   EXIT_MODE   Comentarios
Rojo       __ / 10         ____              down/right  ______________________
Verde      __ / 10         ____              down/right  ______________________
Azul       __ / 10         ____              down/right  ______________________
Amarillo   __ / 10         ____              down/right  ______________________
```

---

## 9) Ajustes rápidos si algo falla

* **Llega tarde** → sube `PRETRIGGER_FRAC` (p. ej. 0.78 → 0.82).
* **Tiembla** → baja `SETTLE_MS` o usa ángulos más cercanos (p. ej. 0/45/90/135°).
* **Confusiones de color** → sube `Smin`/`Vmin` en los rangos HSV y mejora iluminación difusa.
* **Falsos por fondo** → cartulina blanca y separar objetos de colores similares.

---

## 10) Entregables (por equipo)

1. **Código Python** (con su `SERIAL_PORT` y parámetros finales).
2. **Firmware** del micro (UNO o ESP32) con **ángulos anotados**.
3. **Tabla de aciertos (10 por color)** + 3 observaciones de mejora.
4. **Screenshot o video corto** mostrando “**SIGUE: color**” y movimiento del servo.

---

## 11) Cronograma sugerido (≈ 2 h)

* 15 min — Montaje y carga de firmware.
* 20 min — Calibración de HSV y líneas (salida / pre-disparo).
* 40 min — Pruebas con M&M’s y ajustes.
* 25 min — Medición (10 por color), captura de evidencia.
* 20 min — Limpieza, conclusiones y entrega.
