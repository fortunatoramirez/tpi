# Práctica 6 — Anatomía de la Detección por Color (análisis paso a paso)

## Objetivo

Entender **cada pieza** del pipeline de color (captura → HSV → segmentación → morfología → contornos → ROI → “siguiente en caer” → rendimiento), con **evidencia guardada** y **parámetros justificados**. Sin actuadores en esta práctica.

---

## Tabla de trabajo (cada equipo)

* **Color principal**: ____________   **Color secundario (control)**: ____________
* **Equipo**: ______________________  **Integrantes**: __________________________
* **Carpeta de salida** (frames/masks/mediciones): `equipo_XXX/`

---

# Bloque 1 — Visor HSV con “sonda” de píxel (H/S/V bajo el mouse)

**Meta:** observar cómo cambian H, S y V con luz/sombras y sacar **rangos preliminares**.

```python
# ===================== B1: VISOR HSV (COMPLETO) =====================
# Acciones:
# - Mueve el mouse sobre el objeto de tu color.
# - Anota 10 muestras de (H, S, V) en distintas zonas (normal, sombra, brillo).
# - Escribe tus notas al final de este archivo o en tu cuaderno.
# ====================================================================
import cv2
import numpy as np

# (NUEVO) Parámetros base
CAM_INDEX = 0
WIDTH, HEIGHT = 1280, 720

cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, HEIGHT)

last_xy = (WIDTH//2, HEIGHT//2)

def on_mouse(event, x, y, flags, param):
    global last_xy
    if event == cv2.EVENT_MOUSEMOVE:
        last_xy = (x, y)

cv2.namedWindow("B1-HSV-Inspector")
cv2.setMouseCallback("B1-HSV-Inspector", on_mouse)

print("[B1] Presiona ESC para salir. Toma 10 lecturas H,S,V en diferentes condiciones.")
while True:
    ok, frame = cap.read()
    if not ok:
        break

    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    x, y = last_xy
    h, s, v = hsv[y, x]  # (NUEVO) Sonda de pixel bajo el mouse

    vis = frame.copy()
    cv2.circle(vis, (x, y), 6, (0, 255, 255), -1)
    txt = f"H:{int(h)} S:{int(s)} V:{int(v)} @({x},{y})"
    cv2.putText(vis, txt, (10, 40), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,0,0), 3)
    cv2.putText(vis, txt, (10, 40), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255,255,255), 2)

    cv2.imshow("B1-HSV-Inspector", vis)
    if cv2.waitKey(1) & 0xFF == 27:
        break

cap.release()
cv2.destroyAllWindows()

# --- ANOTACIONES (equipo): pega aquí tus 10 lecturas típicas de H,S,V ---
# Ejemplo:
# Luz normal: H ~ [85..95], S ~ [140..200], V ~ [120..210]
# Sombra:     H ~ [...],   S ~ [...],       V ~ [...]
# Brillo:     H ~ [...],   S ~ [...],       V ~ [...]
```

---

# Bloque 2 — Segmentador por color con *trackbars* + guardado de evidencia

**Meta:** construir y **guardar** máscara + frame con **rangos HSV** propios (3 escenarios: normal, sombra, brillo).

```python
# ================== B2: SEGMENTADOR HSV + GUARDADO (COMPLETO) ==================
# Acciones:
# - Ajusta Hmin/Hmax/Smin/Smax/Vmin/Vmax con trackbars.
# - Presiona 's' para guardar pares (frame y mask) en tu carpeta de equipo.
# - Guarda al menos 3 ejemplos: luz normal, sombra, brillo.
# ===============================================================================
import cv2
import numpy as np
import os, time

CAM_INDEX = 0
SAVE_DIR = "equipo_demo"   # (NUEVO) Cambia a tu carpeta de equipo
os.makedirs(f"{SAVE_DIR}/frames", exist_ok=True)
os.makedirs(f"{SAVE_DIR}/masks",  exist_ok=True)

def nothing(a): pass
cv2.namedWindow("B2-Segment")
# (NUEVO) Valores iniciales sugeridos (ajústalos según B1)
init = dict(Hmin=80, Hmax=140, Smin=120, Smax=255, Vmin=70, Vmax=255)
for (name, val, maxv) in [
    ("Hmin", init["Hmin"], 179), ("Hmax", init["Hmax"], 179),
    ("Smin", init["Smin"], 255), ("Smax", init["Smax"], 255),
    ("Vmin", init["Vmin"], 255), ("Vmax", init["Vmax"], 255),
]:
    cv2.createTrackbar(name, "B2-Segment", val, maxv, nothing)

cap = cv2.VideoCapture(CAM_INDEX)
while True:
    ok, frame = cap.read()
    if not ok: break
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    # (NUEVO) Lee sliders
    Hmin=cv2.getTrackbarPos("Hmin","B2-Segment")
    Hmax=cv2.getTrackbarPos("Hmax","B2-Segment")
    Smin=cv2.getTrackbarPos("Smin","B2-Segment")
    Smax=cv2.getTrackbarPos("Smax","B2-Segment")
    Vmin=cv2.getTrackbarPos("Vmin","B2-Segment")
    Vmax=cv2.getTrackbarPos("Vmax","B2-Segment")

    low  = np.array([Hmin, Smin, Vmin], dtype=np.uint8)
    high = np.array([Hmax, Smax, Vmax], dtype=np.uint8)

    mask = cv2.inRange(hsv, low, high)
    # (NUEVO) Morfología simple para limpiar puntos sueltos
    k = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, iterations=1)

    # Vista combinada
    mask_bgr = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
    comb = np.hstack([frame, mask_bgr])

    txt = f"H[{Hmin},{Hmax}] S[{Smin},{Smax}] V[{Vmin},{Vmax}]"
    cv2.putText(comb, txt, (10, 40), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,0,0), 3)
    cv2.putText(comb, txt, (10, 40), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255,255,255), 2)
    cv2.imshow("B2-Segment", comb)

    kkey = cv2.waitKey(1) & 0xFF
    if kkey == 27:  # ESC
        break
    if kkey == ord('s'):  # (NUEVO) Guardado de evidencia
        ts = int(time.time()*1000)
        cv2.imwrite(f"{SAVE_DIR}/frames/{ts}.png", frame)
        cv2.imwrite(f"{SAVE_DIR}/masks/{ts}.png",  mask)
        print("[B2] Guardado:", ts, txt)

cap.release()
cv2.destroyAllWindows()

# --- ANOTACIONES ---
# Escribe aquí tus rangos finales elegidos para tu color:
# H:[.., ..], S:[.., ..], V:[.., ..]  (explica por qué)
```

---

# Bloque 3 — Laboratorio de morfología (OPEN/CLOSE, kernels 3×3 y 5×5)

**Meta:** saber **cuándo** usar OPEN vs CLOSE.

```python
# =================== B3: MORFOLOGÍA OPEN vs CLOSE (COMPLETO) ===================
# Acciones:
# - Mantén los rangos de B2 que capturan tu color (o carga una máscara guardada).
# - Compara OPEN/CLOSE con kernels 3x3 y 5x5 en tiempo real.
# - Escribe 2 reglas: ¿cuándo OPEN? ¿cuándo CLOSE?
# ===============================================================================
import cv2
import numpy as np

CAM_INDEX = 0

# (NUEVO) RANGOS elegidos por tu equipo (pon aquí los tuyos)
Hmin,Hmax = 80,140
Smin,Smax = 120,255
Vmin,Vmax = 70,255

cap = cv2.VideoCapture(CAM_INDEX)
print("[B3] ESC para salir. Observa diferencias entre OPEN/CLOSE 3x3 y 5x5.")
while True:
    ok, frame = cap.read()
    if not ok: break

    hsv  = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    low  = np.array([Hmin,Smin,Vmin]); high = np.array([Hmax,Smax,Vmax])
    mask = cv2.inRange(hsv, low, high)

    k3 = np.ones((3,3), np.uint8)
    k5 = np.ones((5,5), np.uint8)

    open3  = cv2.morphologyEx(mask, cv2.MORPH_OPEN,  k3, iterations=1)  # (NUEVO)
    close3 = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, k3, iterations=1)  # (NUEVO)
    open5  = cv2.morphologyEx(mask, cv2.MORPH_OPEN,  k5, iterations=1)  # (NUEVO)
    close5 = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, k5, iterations=1)  # (NUEVO)

    top = np.hstack([cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR),
                     cv2.cvtColor(open3, cv2.COLOR_GRAY2BGR),
                     cv2.cvtColor(close3, cv2.COLOR_GRAY2BGR)])
    bot = np.hstack([cv2.cvtColor(open5, cv2.COLOR_GRAY2BGR),
                     cv2.cvtColor(close5, cv2.COLOR_GRAY2BGR),
                     frame])
    grid = np.vstack([top, bot])

    cv2.putText(grid, "RAW | OPEN3 | CLOSE3", (10,30), cv2.FONT_HERSHEY_SIMPLEX, 1,(255,255,255),2)
    cv2.putText(grid, "OPEN5 | CLOSE5 | FRAME", (10,30+grid.shape[0]//2), cv2.FONT_HERSHEY_SIMPLEX, 1,(255,255,255),2)
    cv2.imshow("B3-Morph-Lab", grid)

    if cv2.waitKey(1) & 0xFF == 27:
        break

cap.release(); cv2.destroyAllWindows()

# --- ANOTACIONES ---
# Regla 1 (ruido granular/pixeles sueltos): usar ______ porque _________
# Regla 2 (agujeros dentro de la pieza): usar ______ porque _________
```

---

# Bloque 4 — Contornos, área mínima y centroide (filtro por tamaño)

**Meta:** filtrar falsos positivos por **área** y visualizar **bounding box** + **centroide**.

```python
# ================== B4: CONTORNOS + AREA_MIN + CENTROIDE (COMPLETO) ==================
# Acciones:
# - Ajusta AREA_MIN hasta que descarte "migajas" pero mantenga tu objeto.
# - Guarda un frame donde se descarte el pequeño y se acepte el grande.
# =====================================================================================
import cv2
import numpy as np
import os, time

CAM_INDEX = 0
SAVE_DIR = "equipo_demo"
os.makedirs(SAVE_DIR, exist_ok=True)

# (NUEVO) Usa tus rangos:
Hmin,Hmax = 80,140
Smin,Smax = 120,255
Vmin,Vmax = 70,255

AREA_MIN = 900  # (NUEVO) Ajusta este valor y justifícalo

cap = cv2.VideoCapture(CAM_INDEX)
print("[B4] Presiona 's' para guardar evidencia del filtrado por AREA_MIN. ESC para salir.")
while True:
    ok, frame = cap.read()
    if not ok: break

    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array([Hmin,Smin,Vmin]), np.array([Hmax,Smax,Vmax]))

    k = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, iterations=1)

    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    vis = frame.copy()
    kept = 0
    for c in cnts:
        area = cv2.contourArea(c)
        x,y,w,h = cv2.boundingRect(c)
        color = (0,0,255)
        if area >= AREA_MIN:
            color = (0,255,0)  # (NUEVO) Aceptado
            kept += 1
            M = cv2.moments(c)
            if M["m00"] != 0:
                cx = int(M["m10"]/M["m00"]); cy = int(M["m01"]/M["m00"])
                cv2.circle(vis,(cx,cy),4,(255,255,255),-1)
        cv2.rectangle(vis,(x,y),(x+w,y+h), color, 2)
        cv2.putText(vis,f"A:{int(area)}",(x,y-6),cv2.FONT_HERSHEY_SIMPLEX,0.6,(255,255,255),2)

    cv2.putText(vis,f"AREA_MIN={AREA_MIN}  kept={kept}",(10,40),cv2.FONT_HERSHEY_SIMPLEX,1,(0,0,0),3)
    cv2.putText(vis,f"AREA_MIN={AREA_MIN}  kept={kept}",(10,40),cv2.FONT_HERSHEY_SIMPLEX,1,(255,255,255),2)

    comb = np.hstack([frame, cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR), vis])
    cv2.imshow("B4-Contours-Area", comb)

    kkey = cv2.waitKey(1) & 0xFF
    if kkey == 27: break
    if kkey == ord('s'):
        ts = int(time.time()*1000)
        cv2.imwrite(os.path.join(SAVE_DIR, f"B4_{ts}.png"), comb)
        print("[B4] Guardado:", f"B4_{ts}.png")

cap.release(); cv2.destroyAllWindows()

# --- ANOTACIONES ---
# Explica por qué elegiste AREA_MIN = ______. ¿Cómo lo estimaste?
```

---

# Bloque 5 — ROI + “Siguiente en caer” (down/right) y línea de pre-disparo

**Meta:** aplicar **ROI** (analizar solo una franja) y decidir **qué objeto caerá primero**. Mide impacto visual.

```python
# ================== B5: ROI + NEXT-TO-FALL + PRE-TRIGGER (COMPLETO) ==================
# Acciones:
# - Cambia EXIT_MODE con d/r. Mueve línea de salida con [ ].
# - Activa/desactiva ROI con 't'. Ajusta ROI_FRAC.
# - Observa cuál objeto es marcado como "SIGUE".
# =====================================================================================
import cv2
import numpy as np

CAM_INDEX = 0
WIDTH, HEIGHT = 1280, 720
EXIT_MODE = "down"     # (NUEVO) 'down' o 'right' -> d/r
EXIT_POS_FRAC = 0.88   # (NUEVO) posición relativa de salida -> [ ]
PRETRIGGER_FRAC = 0.78 # (NUEVO) guía para "ya casi cae"
USE_ROI = True         # (NUEVO) alternar con 't'
ROI_FRAC = 0.35        # (NUEVO) porcentaje inferior/derecho a analizar

# RANGOS (usa los tuyos)
Hmin,Hmax = 80,140
Smin,Smax = 120,255
Vmin,Vmax = 70,255
AREA_MIN  = 900

cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, HEIGHT)

def find_objects(mask, x0y0x1y1=None):
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    objs = []
    for c in cnts:
        a = cv2.contourArea(c)
        if a < AREA_MIN: continue
        x,y,w,h = cv2.boundingRect(c)
        M = cv2.moments(c)
        if M["m00"]==0: continue
        cx, cy = int(M["m10"]/M["m00"]), int(M["m01"]/M["m00"])
        if x0y0x1y1 is not None:
            x0,y0,x1,y1 = x0y0x1y1
            cx, cy = cx + x0, cy + y0  # (NUEVO) compensación ROI
            x, y = x + x0, y + y0
        objs.append(((x,y,w,h),(cx,cy), a))
    return objs

while True:
    ok, frame = cap.read()
    if not ok: break
    H, W = frame.shape[:2]

    # (NUEVO) ROI
    if USE_ROI:
        if EXIT_MODE=="down":
            y0 = int(H*(1.0-ROI_FRAC)); y1 = H
            x0 = 0; x1 = W
        else: # right
            x0 = int(W*(1.0-ROI_FRAC)); x1 = W
            y0 = 0; y1 = H
        roi_frame = frame[y0:y1, x0:x1]
    else:
        x0=y0=0; x1=W; y1=H
        roi_frame = frame

    hsv = cv2.cvtColor(cv2.GaussianBlur(roi_frame,(5,5),0), cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array([Hmin,Smin,Vmin]), np.array([Hmax,Smax,Vmax]))
    k = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, iterations=1)

    objs = find_objects(mask, (x0,y0,x1,y1) if USE_ROI else None)

    exit_pos = int((H if EXIT_MODE=="down" else W)*EXIT_POS_FRAC)
    pre_pos  = int((H if EXIT_MODE=="down" else W)*PRETRIGGER_FRAC)

    # (NUEVO) elige siguiente en caer
    best, bestdist = None, 1e9
    for ((x,y,w,h),(cx,cy),a) in objs:
        d = (exit_pos - cy) if EXIT_MODE=="down" else (exit_pos - cx)
        if 0 < d < bestdist:
            best, bestdist = ((x,y,w,h),(cx,cy),a), d

    vis = frame.copy()
    # Dibujos: líneas de salida y pre-disparo
    if EXIT_MODE=="down":
        cv2.line(vis,(0,exit_pos),(W,exit_pos),(0,255,255),2)
        cv2.line(vis,(0,pre_pos),(W,pre_pos),(255,0,0),1)
    else:
        cv2.line(vis,(exit_pos,0),(exit_pos,H),(0,255,255),2)
        cv2.line(vis,(pre_pos,0),(pre_pos,H),(255,0,0),1)

    # Dibuja objetos
    for ((x,y,w,h),(cx,cy),a) in objs:
        cv2.rectangle(vis,(x,y),(x+w,y+h),(0,255,0),2)
        cv2.circle(vis,(cx,cy),4,(255,255,255),-1)
    if best is not None:
        (x,y,w,h),(cx,cy),_ = best
        cv2.rectangle(vis,(x,y),(x+w,y+h),(0,0,0),3)
        cv2.putText(vis, "SIGUE", (x, max(0,y-8)), cv2.FONT_HERSHEY_SIMPLEX, 0.7,(255,255,255),2)

    hud = f"EXIT:{EXIT_MODE}  ROI:{USE_ROI}({int(ROI_FRAC*100)}%)  AREA_MIN:{AREA_MIN}"
    cv2.putText(vis, hud, (10,40), cv2.FONT_HERSHEY_SIMPLEX, 1,(0,0,0),3)
    cv2.putText(vis, hud, (10,40), cv2.FONT_HERSHEY_SIMPLEX, 1,(255,255,255),2)

    cv2.imshow("B5-ROI-NextToFall", vis)
    key = cv2.waitKey(1) & 0xFF
    if key==27: break
    elif key==ord('d'): EXIT_MODE="down"
    elif key==ord('r'): EXIT_MODE="right"
    elif key==ord('['): EXIT_POS_FRAC=max(0.5, EXIT_POS_FRAC-0.02)
    elif key==ord(']'): EXIT_POS_FRAC=min(0.98, EXIT_POS_FRAC+0.02)
    elif key==ord('t'): USE_ROI = not USE_ROI
    elif key==ord('-'): ROI_FRAC=max(0.10, ROI_FRAC-0.05)
    elif key==ord('+') or key==ord('='): ROI_FRAC=min(0.90, ROI_FRAC+0.05)

cap.release()
cv2.destroyAllWindows()

# --- ANOTACIONES ---
# ¿La ROI redujo falsos positivos? ¿Dónde colocaste ROI_FRAC? ¿Por qué?
```

---

# Bloque 6 — Medición simple de **FPS** (rendimiento)

**Meta:** medir FPS con/sin ROI y con distintos kernels. Reporta qué mejora más el rendimiento.

```python
# ========================= B6: MEDIDOR DE FPS (COMPLETO) =========================
# Acciones:
# - Observa FPS con ROI activada/desactivada y con distintos kernels morfológicos.
# - Reporta qué factor impacta más en FPS (resolución, ROI, morfología).
# =================================================================================
import cv2
import numpy as np
import time

CAM_INDEX = 0
WIDTH, HEIGHT = 1280, 720
USE_ROI = True
ROI_FRAC = 0.35

# RANGOS (tuyos)
Hmin,Hmax = 80,140
Smin,Smax = 120,255
Vmin,Vmax = 70,255

AREA_MIN  = 900
KERNEL_SZ = 5    # (NUEVO) prueba con 3 y 5

cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  WIDTH)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, HEIGHT)

t0 = time.time()
frames = 0

print("[B6] Teclas: t (toggle ROI)  -/+ (ROI_FRAC)  3/5 (kernel)  ESC salir")
while True:
    ok, frame = cap.read()
    if not ok: break
    H, W = frame.shape[:2]

    if USE_ROI:
        x0=y0=0; x1=W; y1=H
        x0 = int(W*(1.0-ROI_FRAC)) if False else 0  # ROI vertical opcional
        y0 = int(H*(1.0-ROI_FRAC)) if True  else 0  # (NUEVO) ROI inferior por defecto
        roi = frame[y0:y1, x0:x1]
    else:
        x0=y0=0; x1=W; y1=H
        roi = frame

    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, np.array([Hmin,Smin,Vmin]), np.array([Hmax,Smax,Vmax]))

    k = np.ones((KERNEL_SZ,KERNEL_SZ), np.uint8)   # (NUEVO) tamaño de kernel variable
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, iterations=1)

    cnts,_ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    vis = frame.copy()
    for c in cnts:
        if cv2.contourArea(c) < AREA_MIN: continue
        x,y,w,h = cv2.boundingRect(c)
        cv2.rectangle(vis, (x+x0,y+y0), (x+x0+w,y+y0+h), (0,255,0), 2)

    frames += 1
    dt = time.time() - t0
    if dt >= 1.0:
        fps = frames / dt
        t0 = time.time(); frames = 0
        print(f"[B6] FPS: {fps:.1f} | ROI:{USE_ROI}({int(ROI_FRAC*100)}%) | K={KERNEL_SZ}")

    hud = f"ROI:{USE_ROI}({int(ROI_FRAC*100)}%)  K={KERNEL_SZ}"
    cv2.putText(vis, hud, (10,40), cv2.FONT_HERSHEY_SIMPLEX, 1,(0,0,0),3)
    cv2.putText(vis, hud, (10,40), cv2.FONT_HERSHEY_SIMPLEX, 1,(255,255,255),2)
    cv2.imshow("B6-FPS", vis)

    key = cv2.waitKey(1) & 0xFF
    if key==27: break
    elif key==ord('t'): USE_ROI = not USE_ROI
    elif key==ord('-'): ROI_FRAC = max(0.10, ROI_FRAC-0.05)
    elif key==ord('+') or key==ord('='): ROI_FRAC = min(0.90, ROI_FRAC+0.05)
    elif key==ord('3'): KERNEL_SZ = 3
    elif key==ord('5'): KERNEL_SZ = 5

cap.release()
cv2.destroyAllWindows()

# --- ANOTACIONES ---
# Compara FPS en 3 condiciones y concluye cuál factor impacta más y por qué.
```

---

## Entregables (por equipo)

1. **B1**: 10 lecturas H/S/V y rangos preliminares.
2. **B2**: 3 pares *frame+mask* guardados y tabla de rangos finales (H,S,V) con justificación.
3. **B3**: Dos **reglas** claras (cuándo usar OPEN y cuándo CLOSE) + ejemplo observado.
4. **B4**: Imagen con descarte/aceptación por **AREA_MIN** + razonamiento del valor elegido.
5. **B5**: Notas de efecto de **ROI** y del *next-to-fall* (down vs right).
6. **B6**: **FPS** comparativos y conclusión de rendimiento.
7. **Mini-informe** (1 página): decisiones tomadas, problemas y mejoras.

---

## Actividad final de **creatividad** (responder en equipo)

Piensen en **qué agregarían** al sistema de la banda en las próximas prácticas. El límite es su imaginación; pueden mezclar visión, control y mecánica. Respondan breve (½–1 página) con:

1. **Idea** (título + 2–3 oraciones): p.ej. *“Detector de atascos con alarma LED”*, *“Aprendizaje rápido de nuevos colores con 5 muestras”*, *“Selección de velocidad de banda según congestión”*.
2. **¿Qué bloque(s) tocarían?** (de B1 a B6) y **qué variable** o **técnica** cambiarían.
3. **Costo y materiales** estimados (muy aproximado).
4. **Riesgos** o limitaciones (y cómo mitigarlos).
5. **Éxito medible** (un KPI): p.ej. *“< 1 falso positivo por 50 piezas”*, *“> 12 FPS con ROI 25%”*, *“tiempo de alineación < 300 ms”*.

> Bonus (+1): incluyan un **boceto** (a mano/foto) o un mini-video de 10–20 s explicando su idea.

---

