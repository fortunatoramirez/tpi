# Práctica (teórica) — Clasificación combinada por **Color → Forma** (pipeline en cascada)

## Bloque 1 — Segmentación por color con **HSV** (inRange)

**Qué es:** convertir BGR→HSV y aplicar umbrales por color con `cv2.inRange`. La máscara binaria resultante “aísla” los píxeles del color objetivo.
**Qué observarían:** cómo **H** (tono) identifica el color, y cómo **S/V** filtran lavados/sombras; ver el efecto de mover Hmin/Hmax, Smin/Vmin.
**Errores típicos:** espectros demasiado amplios (capturan fondo), o S/V muy bajos (píxeles grises cuelan ruido).
**Video:** “Espacio de color y detección de color” (HSV) — YouTube. ([youtube.com][2])

---

## Bloque 2 — Limpieza con **morfología** (opening/closing)

**Qué es:** operaciones sobre la máscara binaria: **opening** (erosión+dilatación) quita puntitos; **closing** rellena huecos.
**Qué observarían:** probar kernels 3×3 vs 5×5; ver cuándo **OPEN** elimina grano y cuándo **CLOSE** tapa agujeros.
**Errores típicos:** kernels muy grandes “encogen”/“engordan” demasiado el objeto.
**Video:** “Transformaciones morfológicas (erosión, dilatación, apertura, cierre)” — YouTube. ([youtube.com][3])

---

## Bloque 3 — **Contornos** y medidas básicas (área, centroide, perímetro)

**Qué es:** extraer contornos con `cv2.findContours` y calcular **área** y **centroide** (momentos). Esto permite filtrar ruido por **AREA_MIN**.
**Qué observarían:** relación entre área y tamaño real del objeto; cómo el centroide se mueve estable respecto al objeto.
**Errores típicos:** no compensar las operaciones morfológicas → contornos “rotos” o múltiples.
**Video:** “Momentos de un objeto: centroide, área y perímetro (OpenCV)” — YouTube. ([youtube.com][4])

---

## Bloque 4 — **Vértices** y polígonos (approxPolyDP)

**Qué es:** aproximar el contorno a un polígono con `cv2.approxPolyDP` y **contar vértices** (triángulo=3, cuadrado=4,…). También sirve el **aspect ratio** del bounding box.
**Qué observarían:** cómo la tolerancia (ε) cambia el conteo de vértices; diferencia entre cuadrado vs rectángulo por relación **w/h ≈ 1**.
**Errores típicos:** elegir ε muy grande (pierde detalle) o muy pequeño (sobrasegmenta).
**Video:** “Aproximación de contornos (ConvexHull y approxPolyDP)” — YouTube. ([youtube.com][5])

---

## Bloque 5 — **Circularidad** y otras descriptores de forma

**Qué es:** medir **circularidad** ( (4\pi A / P^2) cerca de 1 para círculos ) y usar **momentos** para propiedades geométricas estables.
**Qué observarían:** diferencia clara entre círculos (c≈1), cuadrados (c más bajo) y X/triángulos (c aún menor); estabilidad frente a pequeñas rotaciones.
**Errores típicos:** perímetros ruidosos bajan artificialmente la circularidad (conviene limpiar con morfología).
**Video:** “Momentos de imagen (OpenCV) — centroide/área y base para descriptores” — YouTube. ([youtube.com][4])

---

## Bloque 6 — Círculos con **HoughCircles**

**Qué es:** usar la transformada de Hough para detectar **círculos** a partir de bordes. Complementa (o valida) la circularidad.
**Qué observarían:** sensibilidad a parámetros (dp, minDist, Canny high/low, min/maxRadius); ver cuándo Hough es más robusto que solo circularidad.
**Errores típicos:** radio mínimo/máximo mal configurados → falsos o pérdidas.
**Video:** “Detector de circunferencias (Hough) con OpenCV + Python” — YouTube. ([youtube.com][6])

---

## Bloque 7 — Líneas y **“X”** con **HoughLines**

**Qué es:** detectar **líneas** (HoughLines/HoughLinesP) y comprobar **perpendicularidad** (~90°) para identificar una “X” (dos líneas que se cruzan).
**Qué observarían:** cómo los umbrales de Hough y Canny afectan la estabilidad; medir ángulos de las líneas y su diferencia respecto a 90°.
**Errores típicos:** ruido de bordes finos/múltiples; conviene ROI + morfología antes.
**Video:** “Detector de líneas (Transformada de Hough) en OpenCV + Python” — YouTube. ([youtube.com][7])
*(Doc de referencia de OpenCV sobre Hough Lines, opcional para leer):* ([OpenCV][8])

---

## Bloque 8 — **Fusión** en cascada: **Color ∧ Forma** (reglas)

**Qué es:** tomar la **máscara por color** como filtro inicial y **validar** con una o varias **pruebas de forma** (vértices / circularidad / Hough). Reglas típicas:

* **AND**: pasa si (Color OK) **y** (Forma OK).
* **Fallback**: si Color incierto (S/V bajos), dar más peso a Forma.
  **Qué observarían:** reducción de falsos positivos del color y mayor robustez a sombras.
  **Errores típicos:** reglas demasiado estrictas (bajan recall) o laxas (bajan precision).
  **Video:** “Detectando figuras geométricas con OpenCV (bases para reglas de forma)” — YouTube. ([youtube.com][9])

---

## Bloque 9 — Medición: **matriz de confusión** básica (sin servo)

**Qué es:** evaluar el clasificador combinando verdaderos/falsos positivos/negativos por clase (colores/formas) y calcular **accuracy, precision, recall, F1**.
**Qué observarían:** qué reglas generan falsos por iluminación/forma; cómo mover umbrales mejora una métrica pero empeora otra (trade-off).
**Errores típicos:** medir pocas muestras; no equilibrar por clase.
**Video:** “La Matriz de Confusión (explicación clara y corta)” — YouTube. ([youtube.com][10])
*(Lectura extra útil sobre precisión/recuperación — Google Developers):* ([Google for Developers][11])

---

## Enlaces: 

[1]: https://opencv.org/blog/color-spaces-in-opencv/?utm_source=chatgpt.com "Color spaces in OpenCV"
[2]: https://www.youtube.com/watch?v=qdEqkdGnsSI&utm_source=chatgpt.com "11 OpenCV: Espacio de color y detección de color | Color ..."
[3]: https://www.youtube.com/watch?v=PO844QRPoxU&utm_source=chatgpt.com "Transformaciones morfológicas | Python - OpenCV"
[4]: https://www.youtube.com/watch?v=sPGfnYuj0-Y&utm_source=chatgpt.com "Momentos de un objeto, centroide, área y perímetro Python ..."
[5]: https://www.youtube.com/watch?v=rxtG1gOzo5E&utm_source=chatgpt.com "Aproximación de contornos con openCV y Python ..."
[6]: https://www.youtube.com/watch?v=guRN-lf2M6o&utm_source=chatgpt.com "OpenCV + Python: Detector de circunferencias por ..."
[7]: https://www.youtube.com/watch?v=fZYaLgixJ_I&utm_source=chatgpt.com "OpenCV + Python: Detector de líneas por transformada de ..."
[8]: https://docs.opencv.org/3.4/d9/db0/tutorial_hough_lines.html?utm_source=chatgpt.com "Hough Line Transform"
[9]: https://www.youtube.com/watch?v=R82EcsCgnfg&utm_source=chatgpt.com "Detectando FIGURAS GEOMÉTRICAS () con OpenCV - Python"
[10]: https://www.youtube.com/watch?v=haEWWO0b42Y&utm_source=chatgpt.com "La Matriz de Confusión"
[11]: https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?hl=es-419&utm_source=chatgpt.com "Exactitud, recuperación, precisión y métricas relacionadas"

---

## Código:


```python
# =====================================================================================
# PRÁCTICA: Inspección de círculos por COLOR → FORMA (borde e interior)
# -------------------------------------------------------------------------------------
# ¿Qué hace este script?
# 1) Segmenta por COLOR en HSV con TRACKBARS (ajustas H/S/V en vivo).
# 2) Encuentra el objeto circular principal (contorno más grande).
# 3) Evalúa:
#    a) BORDE (anillo): continuidad del color (detecta "grietas" o bordes rotos).
#    b) INTERIOR (disco): cobertura de color (detecta "parches" sin color).
# 4) Pinta en la imagen:
#    - Grietas del borde en ROJO (anillo ∧ ¬color).
#    - Huecos internos en CIAN (interior ∧ ¬color).
# 5) Clasifica: "OK", "Borde defectuoso" o "Cobertura incompleta".
#
# -------------------------------------------------------------------------------------
# ¿Cómo ajusto las opciones?
# A) UMBRALES HSV (para segmentar tu color):
#    - En la ventana "HSV-Trackbars" mueve Hmin/Hmax/Smin/Smax/Vmin/Vmax.
#      *H es el tono del color; S y V ayudan a ignorar zonas grises/sombras.*
#    - TIP rojo: si Hmin > Hmax, el código usa umbral "circular" (dos rangos), útil para ROJO.
#
# B) MORFOLOGÍA (limpieza de máscara):
#    - Tecla 5: alterna kernel 3↔5 (más grande = suaviza más pero puede "engordar" el objeto).
#
# C) INSPECCIÓN del BORDE e INTERIOR (teclas):
#    - 1 / ! : baja/sube EDGE_COVER_THR (umbral de cobertura del ANILLO, 0..1).
#    - 2 / @ : baja/sube FILL_COVER_THR (umbral de cobertura del INTERIOR, 0..1).
#    - 3 / # : reduce/aumenta RING_THICK_FRAC (grosor del anillo relativo al radio).
#    - 4 / $ : reduce/aumenta INNER_MARGIN_FRAC (margen para el disco interior).
#    - s     : guardar screenshot con overlays.
#    - g     : mostrar/ocultar ventana con máscaras (debug).
#    - q o ESC: salir.
#
# Recomendación inicial (M&M azules):
#    - H:[80..140], S:[120..255], V:[70..255]
#    - KERNEL 5, RING 0.12, MARGIN 0.20
#    - EDGE_THR 0.90, FILL_THR 0.95
#
# =====================================================================================

import cv2
import numpy as np
import time

# ------------------------- Parámetros globales (puedes dejar así de inicio) -------------------------
CAM_INDEX = 0
W, H = 1280, 720

# Segmentación / limpieza
BLUR_K     = 5      # tamaño de blur gaussiano previo (5x5)
KERNEL_SZ  = 5      # tamaño de kernel morfológico (3 o 5)

# Inspección del borde/interior (valores iniciales razonables)
RING_THICK_FRAC   = 0.12   # grosor del anillo = 12% del radio
INNER_MARGIN_FRAC = 0.20   # margen desde el borde hacia adentro para el disco interior (20% del radio)
EDGE_COVER_THR    = 0.90   # cobertura mínima del borde (0..1)
FILL_COVER_THR    = 0.95   # cobertura mínima del interior (0..1)

# Filtrado de imperfecciones muy pequeñas (en fracción del área del círculo)
GAP_MIN_FRAC   = 0.003     # área mínima de un "gap" de borde / área del círculo
HOLE_MIN_FRAC  = 0.005     # área mínima de un "hueco" interior / área del círculo

# UI / depuración
SHOW_MASKS = True          # ventana con máscaras auxiliares
help_text  = "Teclas: 1/! EDGE_THR  2/@ FILL_THR  3/# RING  4/$ MARGIN  5 KERNEL  g MASC  s SAVE  q/ESC salir"


# ------------------------- Utilidades varias -------------------------
def clamp(x, lo, hi):
    return max(lo, min(hi, x))

def build_hsv_mask(hsv, Hmin, Hmax, Smin, Smax, Vmin, Vmax):
    """
    Construye una máscara HSV permitiendo que Hmin > Hmax (umbral 'circular').
    Esto sirve para colores que cruzan el 0° (p.ej., ROJO).
    """
    if Hmin <= Hmax:
        low  = np.array([Hmin, Smin, Vmin], dtype=np.uint8)
        high = np.array([Hmax, Smax, Vmax], dtype=np.uint8)
        mask = cv2.inRange(hsv, low, high)
    else:
        # Rango circular: [Hmin,179] U [0,Hmax]
        low1  = np.array([Hmin, Smin, Vmin], dtype=np.uint8)
        high1 = np.array([179,  Smax, Vmax], dtype=np.uint8)
        low2  = np.array([0,    Smin, Vmin], dtype=np.uint8)
        high2 = np.array([Hmax, Smax, Vmax], dtype=np.uint8)
        mask1 = cv2.inRange(hsv, low1, high1)
        mask2 = cv2.inRange(hsv, low2, high2)
        mask  = cv2.bitwise_or(mask1, mask2)

    # Morfología: opening para quitar puntitos/ruido
    k = np.ones((KERNEL_SZ, KERNEL_SZ), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, k, iterations=1)
    return mask

def largest_contour(mask):
    """ Devuelve el contorno más grande (o None si no hay) """
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return None
    return max(cnts, key=cv2.contourArea)

def circularity(cnt):
    """ 4πA/P² ≈ 1 para círculo perfecto """
    A = cv2.contourArea(cnt)
    P = cv2.arcLength(cnt, True)
    if P == 0: return 0.0
    return 4.0 * np.pi * A / (P * P)

def make_ring_mask(shape, cx, cy, r, thick):
    """ Anillo = disco(r) XOR disco(r - thick) """
    outer = np.zeros(shape, dtype=np.uint8)
    inner = np.zeros(shape, dtype=np.uint8)
    cv2.circle(outer, (cx, cy), int(r),          255, -1)
    cv2.circle(inner, (cx, cy), max(1,int(r-thick)), 255, -1)
    return cv2.bitwise_xor(outer, inner)

def make_disk_mask(shape, cx, cy, r):
    disk = np.zeros(shape, dtype=np.uint8)
    cv2.circle(disk, (cx, cy), int(r), 255, -1)
    return disk

def coverage_and_gaps(mask_color, ring_mask, circle_area):
    """
    BORDE: cobertura = (pixeles de color ∧ anillo) / (pixeles del anillo)
    'Gaps' = (anillo ∧ ¬color), filtrados por área mínima relativa al círculo.
    """
    ring_area = int(np.count_nonzero(ring_mask))
    if ring_area == 0:
        return 0.0, 0, 0.0, np.zeros_like(ring_mask)

    ring_color = cv2.bitwise_and(mask_color, ring_mask)
    cov = float(np.count_nonzero(ring_color)) / ring_area

    gaps = cv2.bitwise_and(ring_mask, cv2.bitwise_not(mask_color))
    # Limpia puntos minúsculos
    gaps = cv2.morphologyEx(gaps, cv2.MORPH_OPEN, np.ones((3,3),np.uint8), iterations=1)

    num, labels, stats, _ = cv2.connectedComponentsWithStats(gaps, connectivity=8)
    gap_count = 0
    max_gap_frac = 0.0
    for i in range(1, num):
        area_i = stats[i, cv2.CC_STAT_AREA]
        frac   = area_i / max(1, circle_area)
        if frac >= GAP_MIN_FRAC:
            gap_count += 1
            max_gap_frac = max(max_gap_frac, frac)

    return cov, gap_count, max_gap_frac, gaps

def interior_coverage_and_holes(mask_color, inner_disk, circle_area):
    """
    INTERIOR: cobertura = (pixeles de color ∧ disco_interior) / (pixeles del disco)
    'Holes' = (disco_interior ∧ ¬color), filtrados por área mínima relativa.
    """
    inner_area = int(np.count_nonzero(inner_disk))
    if inner_area == 0:
        return 0.0, 0, 0.0, np.zeros_like(inner_disk)

    filled = cv2.bitwise_and(mask_color, inner_disk)
    cov = float(np.count_nonzero(filled)) / inner_area

    holes = cv2.bitwise_and(inner_disk, cv2.bitwise_not(mask_color))
    holes = cv2.morphologyEx(holes, cv2.MORPH_OPEN, np.ones((3,3),np.uint8), iterations=1)

    num, labels, stats, _ = cv2.connectedComponentsWithStats(holes, connectivity=8)
    hole_count = 0
    max_hole_frac = 0.0
    for i in range(1, num):
        area_i = stats[i, cv2.CC_STAT_AREA]
        frac   = area_i / max(1, circle_area)
        if frac >= HOLE_MIN_FRAC:
            hole_count += 1
            max_hole_frac = max(max_hole_frac, frac)

    return cov, hole_count, max_hole_frac, holes

def classify(edge_cov, edge_gaps, fill_cov, hole_cnt):
    """ Reglas simples de decisión """
    if edge_cov < EDGE_COVER_THR or edge_gaps > 0:
        return "Borde defectuoso"
    if fill_cov < FILL_COVER_THR or hole_cnt > 0:
        return "Cobertura incompleta"
    return "OK"


# ------------------------- Trackbars HSV (para tunear tu color) -------------------------
# Sugerencia inicial (M&M azul): H:[80..140] S:[120..255] V:[70..255]
def nothing(_): pass

cv2.namedWindow("HSV-Trackbars", cv2.WINDOW_NORMAL)
cv2.resizeWindow("HSV-Trackbars", 500, 260)
cv2.createTrackbar("Hmin","HSV-Trackbars", 80, 179, nothing)
cv2.createTrackbar("Hmax","HSV-Trackbars",140, 179, nothing)
cv2.createTrackbar("Smin","HSV-Trackbars",120, 255, nothing)
cv2.createTrackbar("Smax","HSV-Trackbars",255, 255, nothing)
cv2.createTrackbar("Vmin","HSV-Trackbars", 70, 255, nothing)
cv2.createTrackbar("Vmax","HSV-Trackbars",255, 255, nothing)


# ------------------------- Captura de cámara y lazo principal -------------------------
cap = cv2.VideoCapture(CAM_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  W)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, H)

snap_idx = 0
print(help_text)

while True:
    ok, frame = cap.read()
    if not ok:
        break

    # 1) Preproceso básico: blur + HSV
    blur = cv2.GaussianBlur(frame, (BLUR_K, BLUR_K), 0)
    hsv  = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)

    # 2) Lee umbrales desde los trackbars (puedes moverlos con el mouse)
    Hmin = cv2.getTrackbarPos("Hmin","HSV-Trackbars")
    Hmax = cv2.getTrackbarPos("Hmax","HSV-Trackbars")
    Smin = cv2.getTrackbarPos("Smin","HSV-Trackbars")
    Smax = cv2.getTrackbarPos("Smax","HSV-Trackbars")
    Vmin = cv2.getTrackbarPos("Vmin","HSV-Trackbars")
    Vmax = cv2.getTrackbarPos("Vmax","HSV-Trackbars")

    # 3) Máscara de color (con soporte de rango circular en H)
    mask_col = build_hsv_mask(hsv, Hmin,Hmax, Smin,Smax, Vmin,Vmax)

    # (Ventana opcional de depuración de máscaras)
    if SHOW_MASKS:
        mask_bgr = cv2.cvtColor(mask_col, cv2.COLOR_GRAY2BGR)
        dbg = np.hstack([frame, mask_bgr])
        cv2.imshow("MASK DEBUG (frame | mask)", dbg)

    vis = frame.copy()
    status = "Sin objeto"

    # 4) Contorno principal (objeto más grande del color)
    cnt = largest_contour(mask_col)
    if cnt is not None and cv2.contourArea(cnt) > 100:
        # 4.1) Círculo mínimo envolvente y circularidad
        (fx, fy), fr = cv2.minEnclosingCircle(cnt)
        cx, cy, r = int(fx), int(fy), float(fr)
        circ = circularity(cnt)

        # Dibujo de referencia del círculo
        cv2.circle(vis, (cx, cy), int(r), (0,255,255), 2)
        cv2.circle(vis, (cx, cy), 3, (0,255,255), -1)

        circle_area = np.pi * (r**2)

        # 5) BORDE (anillo de inspección)
        ring_thick = max(2, int(r * RING_THICK_FRAC))           # grosor en px
        ring_mask  = make_ring_mask(mask_col.shape, cx, cy, r, ring_thick)

        edge_cov, edge_gap_count, max_gap_frac, gaps_mask = coverage_and_gaps(
            mask_col, ring_mask, circle_area
        )

        # Pintar grietas del borde en ROJO translúcido
        red = np.zeros_like(vis); red[gaps_mask>0] = (0,0,255)
        vis = cv2.addWeighted(vis, 1.0, red, 0.6, 0)

        # 6) INTERIOR (disco de inspección, alejado del borde)
        inner_r = max(1, int(r * (1.0 - INNER_MARGIN_FRAC) - ring_thick))
        inner_disk = make_disk_mask(mask_col.shape, cx, cy, inner_r)

        fill_cov, hole_count, max_hole_frac, holes_mask = interior_coverage_and_holes(
            mask_col, inner_disk, circle_area
        )

        # Pintar huecos internos en CIAN translúcido
        cyan = np.zeros_like(vis); cyan[holes_mask>0] = (255,255,0)  # BGR
        vis = cv2.addWeighted(vis, 1.0, cyan, 0.5, 0)

        # 7) Decisión final
        status = classify(edge_cov, edge_gap_count, fill_cov, hole_count)

        # 8) HUD con métricas y parámetros (lee estos números para tus apuntes)
        hud1 = f"circ={circ:.2f}  edge_cov={edge_cov:.2f} gaps={edge_gap_count} (max_gap={max_gap_frac:.4f})"
        hud2 = f"fill_cov={fill_cov:.2f} holes={hole_count} (max_hole={max_hole_frac:.4f})"
        hud3 = f"RING={RING_THICK_FRAC:.2f}  MARGIN={INNER_MARGIN_FRAC:.2f}  EDGE_THR={EDGE_COVER_THR:.2f}  FILL_THR={FILL_COVER_THR:.2f}  K={KERNEL_SZ}"
        hsvtxt = f"H[{Hmin},{Hmax}] S[{Smin},{Smax}] V[{Vmin},{Vmax}]  (Hmin>Hmax => rango circular)"
        cv2.putText(vis, hud1, (10, 28), cv2.FONT_HERSHEY_SIMPLEX, 0.70, (0,0,0), 3)
        cv2.putText(vis, hud1, (10, 28), cv2.FONT_HERSHEY_SIMPLEX, 0.70, (255,255,255), 2)
        cv2.putText(vis, hud2, (10, 52), cv2.FONT_HERSHEY_SIMPLEX, 0.70, (0,0,0), 3)
        cv2.putText(vis, hud2, (10, 52), cv2.FONT_HERSHEY_SIMPLEX, 0.70, (255,255,255), 2)
        cv2.putText(vis, hud3, (10, 76), cv2.FONT_HERSHEY_SIMPLEX, 0.60, (0,0,0), 3)
        cv2.putText(vis, hud3, (10, 76), cv2.FONT_HERSHEY_SIMPLEX, 0.60, (255,255,255), 1)
        cv2.putText(vis, hsvtxt,(10,100), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (0,0,0), 3)
        cv2.putText(vis, hsvtxt,(10,100), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (255,255,255), 1)

        col = (0,255,0) if status=="OK" else (0,0,255)
        cv2.putText(vis, status, (10, 128), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0,0,0), 4)
        cv2.putText(vis, status, (10, 128), cv2.FONT_HERSHEY_SIMPLEX, 1.0, col,        2)

    else:
        cv2.putText(vis, status, (10, 28), cv2.FONT_HERSHEY_SIMPLEX, 0.80, (0,0,0), 3)
        cv2.putText(vis, status, (10, 28), cv2.FONT_HERSHEY_SIMPLEX, 0.80, (255,255,255), 2)

    # Ayuda y visualización
    cv2.putText(vis, help_text, (10, H-12), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (0,0,0), 3)
    cv2.putText(vis, help_text, (10, H-12), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (255,255,255), 1)
    cv2.imshow("Inspeccion: Color→Círculo (borde + interior)", vis)

    # ------------------------- Controles de teclado -------------------------
    key = cv2.waitKey(1) & 0xFF
    if key in (27, ord('q')):     # ESC o q => salir
        break
    elif key == ord('1'):         # bajar EDGE threshold
        EDGE_COVER_THR = clamp(EDGE_COVER_THR - 0.02, 0.50, 0.99)
    elif key == ord('!'):         # subir EDGE threshold (Shift+1)
        EDGE_COVER_THR = clamp(EDGE_COVER_THR + 0.02, 0.50, 0.99)
    elif key == ord('2'):         # bajar FILL threshold
        FILL_COVER_THR = clamp(FILL_COVER_THR - 0.02, 0.50, 0.99)
    elif key == ord('@'):         # subir FILL threshold (Shift+2)
        FILL_COVER_THR = clamp(FILL_COVER_THR + 0.02, 0.50, 0.99)
    elif key == ord('3'):         # anillo más delgado
        RING_THICK_FRAC = clamp(RING_THICK_FRAC - 0.02, 0.04, 0.40)
    elif key == ord('#'):         # anillo más grueso (Shift+3)
        RING_THICK_FRAC = clamp(RING_THICK_FRAC + 0.02, 0.04, 0.40)
    elif key == ord('4'):         # margen interior menor (disco más grande)
        INNER_MARGIN_FRAC = clamp(INNER_MARGIN_FRAC - 0.02, 0.05, 0.60)
    elif key == ord('$'):         # margen interior mayor (disco más pequeño) (Shift+4)
        INNER_MARGIN_FRAC = clamp(INNER_MARGIN_FRAC + 0.02, 0.05, 0.60)
    elif key == ord('5'):         # alterna kernel 3↔5
        KERNEL_SZ = 3 if KERNEL_SZ == 5 else 5
    elif key == ord('g'):         # mostrar/ocultar máscaras
        SHOW_MASKS = not SHOW_MASKS
        if not SHOW_MASKS:
            try: cv2.destroyWindow("MASK DEBUG (frame | mask)")
            except: pass
    elif key == ord('s'):         # guardar captura con overlays
        fn = f"mm_inspect_{int(time.time())}.png"
        cv2.imwrite(fn, vis)
        print("Guardado:", fn)

cap.release()
cv2.destroyAllWindows()
```

---

## Actividades por equipo:

* Ajustar **H/S/V** en los **trackbars** hasta que la máscara capture bien su M&M (sin fondo).
* Probar **KERNEL 3 y 5** (tecla 5) y anotar cómo afecta el ruido y la forma.
* Afinar **RING_THICK_FRAC** (3/#) y **INNER_MARGIN_FRAC** (4/$) para que el **anillo** y el **disco interior** midan donde corresponde.
* Ajustar **EDGE_COVER_THR** (1/!) y **FILL_COVER_THR** (2/@) para separar correctamente **OK** vs **defectos**.
* Forzar casos con **borde roto** (píntale una rayita al borde) y **huecos internos** (raspar un poco el color) y verificar que el overlay los marque (ROJO y CIAN).
* Guardar **screenshots** (s) como evidencia con los **HUDs** (métricas y parámetros visibles).
* Escribir una breve **explicación** de:

  * por qué sus umbrales HSV funcionan,
  * cómo eligieron el grosor del anillo y el margen interior,
  * qué cambian si hay más brillo o el objeto es más pequeño.
