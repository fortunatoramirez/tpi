# Práctica — Inspección de M&M en tiempo real con tolerancia ajustable a imperfecciones

## 0) Controles de la interfaz (al inicio)

La app abre la cámara y muestra **anotaciones en tiempo real** para cada M&M detectado: **OK** o **RECHAZO** con las **razones** (didáctico). En la ventana “Controles” hay *sliders* para ajustar la tolerancia:

* **Blur (odd)**: Tamaño del desenfoque gaussiano (impar). Útil para reducir ruido.
  *Recomendado iniciar en 5–9.*
* **Canny low / Canny high**: Umbrales de detección de bordes.
  *Empiece con 50 / 150 y ajuste hasta que el borde del M&M sea continuo.*
* **Min/Max diam (px)**: Rango de **tamaño** aceptado (diámetro en *pixeles*).
  *Úselo para adaptar la escala (cámara cerca/lejos). Ajuste primero esto.*
* **Min circularity %**: Qué tan “circular” debe ser (100% = círculo perfecto).
  *Suba si el sistema acepta óvalos; baje si rechaza círculos “normales” con ligera ovalidad.*
* **Max eccentricity %**: Límite de ovalidad (0% = círculo, ↑ = más ovalo permitido).
  *Si hay M&M naturalmente alargados por perspectiva, incremente este valor.*
* **Min solidity %**: Penaliza muescas, bordes mordidos o faltantes (100% = contorno convexo perfecto).
  *Si marca rechazo por muescas leves, baje un poco; si deja pasar piezas con “mordidas”, súbalo.*
* **Δcolor thr (Lab)**: Sensibilidad a **cuarteaduras/faltantes de color** internos (basado en ΔE contra el color medio del M&M).
  *Más alto = detecta más diferencias; si hay falsas alarmas por brillo, bájelo.*
* **Max defect %**: Porcentaje máximo de pixeles internos “defectuosos” permitido.
  *Si una pieza sana se rechaza por pequeñas variaciones, suba este número.*
* **Show edges (0/1)**: Muestra al lado la vista de bordes para entender qué está detectando.

**Teclas:** `q` salir · `s` guardar captura con anotaciones.

---

## 1) Objetivo general

Desarrollar y calibrar una interfaz **interactiva en tiempo real** para **clasificar M&M** como ACEPTADO/RECHAZADO, **tolerando imperfecciones circulares normales** y **detectando defectos reales** (muescas, cuarteaduras, faltantes de color), con **controles didácticos** que el alumno ajusta en vivo.

## 2) Objetivos específicos

1. Medir y usar **rasgos geométricos**: circularidad, excentricidad, solidez y tamaño.
2. Medir **defecto de color interno** con ΔE (espacio Lab) contra el color medio de la pieza.
3. Ajustar **umbrales** con *feedback* visual inmediato hasta lograr un **punto de operación** robusto.
4. Documentar el **proceso de calibración** y justificar las decisiones.

## 3) Marco teórico mínimo

* **Circularidad:** ( C=\frac{4\pi A}{P^2} \in (0,1] ). 1 → círculo perfecto. Baje umbral si rechaza círculos “normales”, súbalo si acepta óvalos.
* **Excentricidad (de elipse):** ( e=\sqrt{1-\frac{b^2}{a^2}} \in [0,1) ). 0 → círculo. Limita ovalidad.
* **Solidez:** ( \text{Solidez}=\frac{\text{Área}}{\text{Área del casco convexo}} \in (0,1] ). Baja con **mordidas**/muescas.
* **Defecto interno por color (ΔE):** en **Lab**, la distancia ( \Delta E=|\vec{L^*a^*b^*}-\text{mediana}_{\text{M&M}}| ) resalta **cuarteaduras/faltantes**.
* **Escala (tamaño):** Primero ajuste **Min/Max diam** (px). (Opcional) Calibre **px/mm** con una moneda o regla.

## 4) Material y software

* PC con cámara web.
* **Python 3.9+**, paquetes: `opencv-python`, `numpy`.
* Superficie con M&Ms (varios casos: normales, con muesca, con zona sin color, ligeramente ovalados).

## 5) Código
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Real-time M&M Inspector (OpenCV)
--------------------------------
Didactic interface with sliders to tune:
- Circularity tolerance (how close to a circle)
- Solidity (penalizes chips/missing pieces)
- Eccentricity (ellipse-based "how oval")
- Size range (min/max diameter in pixels)
- Color-defect sensitivity & max allowed defect % (detect cracks / bare spots)
- Preprocessing (blur + Canny thresholds)

Keys:
  q: quit
  s: save annotated frame to ./mm_snapshot.png

Requirements:
  pip install opencv-python numpy
"""

import cv2
import numpy as np
import time
from math import sqrt, pi

WIN_CTRL = "Controles"
WIN_VIEW = "Vista"

def ensure_odd(n: int, minimum: int = 1, maximum: int = 31) -> int:
    n = max(minimum, min(maximum, n))
    if n % 2 == 0:
        n += 1 if n < maximum else -1
    return n

def nothing(_):  # Trackbar callback placeholder
    pass

def make_windows():
    cv2.namedWindow(WIN_CTRL, cv2.WINDOW_AUTOSIZE)
    cv2.namedWindow(WIN_VIEW, cv2.WINDOW_NORMAL)
    cv2.resizeWindow(WIN_VIEW, 1280, 720)

    # Preprocess
    cv2.createTrackbar("Blur (odd)", WIN_CTRL, 5, 31, nothing)           # Gaussian kernel size
    cv2.createTrackbar("Canny low", WIN_CTRL, 50, 255, nothing)
    cv2.createTrackbar("Canny high", WIN_CTRL, 150, 255, nothing)

    # Geometry filters
    cv2.createTrackbar("Min diam (px)", WIN_CTRL, 30, 600, nothing)
    cv2.createTrackbar("Max diam (px)", WIN_CTRL, 200, 1000, nothing)
    cv2.createTrackbar("Min circularity %", WIN_CTRL, 75, 100, nothing)  # 100 = perfect circle
    cv2.createTrackbar("Max eccentricity %", WIN_CTRL, 35, 100, nothing) # 0 perfect circle, 100 very elongated
    cv2.createTrackbar("Min solidity %", WIN_CTRL, 90, 100, nothing)     # 100 = convex, < penalizes chips

    # Color defect tuning
    cv2.createTrackbar("Δcolor thr (Lab)", WIN_CTRL, 18, 100, nothing)   # sensitivity for cracks/bare spots
    cv2.createTrackbar("Max defect %", WIN_CTRL, 8, 100, nothing)        # max % pixels flagged inside object

    # Display options
    cv2.createTrackbar("Show edges (0/1)", WIN_CTRL, 1, 1, nothing)

def read_params():
    blur_k = ensure_odd(cv2.getTrackbarPos("Blur (odd)", WIN_CTRL), 1, 31)
    c_lo   = cv2.getTrackbarPos("Canny low", WIN_CTRL)
    c_hi   = cv2.getTrackbarPos("Canny high", WIN_CTRL)
    dmin   = max(5, cv2.getTrackbarPos("Min diam (px)", WIN_CTRL))
    dmax   = max(dmin, cv2.getTrackbarPos("Max diam (px)", WIN_CTRL))
    circ   = cv2.getTrackbarPos("Min circularity %", WIN_CTRL) / 100.0
    ecc    = cv2.getTrackbarPos("Max eccentricity %", WIN_CTRL) / 100.0
    soli   = cv2.getTrackbarPos("Min solidity %", WIN_CTRL) / 100.0
    dcol   = cv2.getTrackbarPos("Δcolor thr (Lab)", WIN_CTRL)  # 0..100
    dmaxp  = cv2.getTrackbarPos("Max defect %", WIN_CTRL)      # 0..100
    show_e = cv2.getTrackbarPos("Show edges (0/1)", WIN_CTRL) == 1
    return blur_k, c_lo, c_hi, dmin, dmax, circ, ecc, soli, dcol, dmaxp, show_e

def circularity(area, perim):
    if perim <= 1e-6:
        return 0.0
    return (4.0 * pi * area) / (perim * perim)

def eccentricity_of(cnt):
    if len(cnt) < 5:
        return 0.0
    ellipse = cv2.fitEllipse(cnt)
    (cx, cy), (MA, ma), angle = ellipse  # MA: major axis length? OpenCV returns (width,height) where width>=height is NOT guaranteed
    # Ensure MA (major) is the larger of the two
    a = max(MA, ma) / 2.0  # semi-major
    b = min(MA, ma) / 2.0  # semi-minor
    if a <= 1e-6:
        return 0.0
    e = sqrt(max(0.0, 1.0 - (b*b)/(a*a)))  # 0 = circle, ->1 elongated
    return float(e)

def solidity_of(cnt):
    area = cv2.contourArea(cnt)
    hull = cv2.convexHull(cnt)
    hull_area = cv2.contourArea(hull) if hull is not None else 0.0
    if hull_area <= 1e-6:
        return 0.0
    return float(area / hull_area)

def lab_deltaE(img_bgr_roi, mask_roi):
    """
    Compute deltaE from per-pixel LAB to median LAB inside mask.
    Returns per-pixel deltaE (float32).
    """
    lab = cv2.cvtColor(img_bgr_roi, cv2.COLOR_BGR2LAB)
    L, A, B = cv2.split(lab)
    mL = np.median(L[mask_roi > 0]).astype(np.float32) if np.any(mask_roi) else 0.0
    mA = np.median(A[mask_roi > 0]).astype(np.float32) if np.any(mask_roi) else 0.0
    mB = np.median(B[mask_roi > 0]).astype(np.float32) if np.any(mask_roi) else 0.0
    dL = (L.astype(np.float32) - mL)
    dA = (A.astype(np.float32) - mA)
    dB = (B.astype(np.float32) - mB)
    dE = np.sqrt(dL*dL + dA*dA + dB*dB)
    return dE

def annotate_object(img, center, radius, ok, reasons, metrics):
    color = (0, 200, 0) if ok else (0, 0, 255)
    cx, cy = int(center[0]), int(center[1])
    cv2.circle(img, (cx, cy), int(radius), color, 2, lineType=cv2.LINE_AA)
    cv2.circle(img, (cx, cy), 2, (255, 255, 255), -1, lineType=cv2.LINE_AA)
    label = "OK" if ok else "RECHAZO"
    cv2.putText(img, label, (cx - 30, cy - int(radius) - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2, cv2.LINE_AA)
    # Show 1-2 reasons for reject
    yoff = 18
    if not ok:
        for i, r in enumerate(reasons[:2]):
            cv2.putText(img, f"- {r}", (cx - int(radius), cy + int(radius) + 20 + i*yoff),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,255), 1, cv2.LINE_AA)
    # Small metrics box
    (circ, ecc, soli, dfx) = metrics
    txt = f"c={circ:.2f} e={ecc:.2f} s={soli:.2f} df%={dfx:.1f}"
    cv2.putText(img, txt, (cx - int(radius), cy - int(radius) - 30),
                cv2.FONT_HERSHEY_SIMPLEX, 0.45, (255,255,255), 1, cv2.LINE_AA)

def stack_side_by_side(a, b):
    h = max(a.shape[0], b.shape[0])
    def pad(img):
        if img.ndim == 2:
            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        dh = h - img.shape[0]
        if dh > 0:
            img = cv2.copyMakeBorder(img, 0, dh, 0, 0, cv2.BORDER_CONSTANT, value=(0,0,0))
        return img
    return np.hstack([pad(a), pad(b)])

def main():
    make_windows()
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("No se pudo abrir la cámara (índice 0). Cambia el índice en el código si es necesario.")
        return

    last_save = 0.0

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        blur_k, c_lo, c_hi, dmin, dmax, min_circ, max_ecc, min_soli, dcol_thr, max_def_pct, show_edges = read_params()

        # Preprocess
        frame_disp = frame.copy()
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        blur_k = ensure_odd(blur_k, 1, 31)
        if blur_k > 1:
            gray_blur = cv2.GaussianBlur(gray, (blur_k, blur_k), 0)
        else:
            gray_blur = gray

        edges = cv2.Canny(gray_blur, c_lo, c_hi)

        # Find external contours
        cnts = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cnts = cnts[0] if len(cnts) == 2 else cnts[1]

        annotated = frame_disp.copy()
        edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)

        for cnt in cnts:
            area = cv2.contourArea(cnt)
            if area < 10:
                continue

            # Enclosing circle for diameter / center
            (x, y), r = cv2.minEnclosingCircle(cnt)
            diam = 2.0 * r

            if diam < dmin or diam > dmax:
                # Still draw a faint circle to show it's being filtered by size
                cv2.circle(annotated, (int(x), int(y)), int(r), (80,80,80), 1, cv2.LINE_AA)
                continue

            perim = cv2.arcLength(cnt, True)
            circ = circularity(area, perim)         # 0..1, 1 best
            ecc  = eccentricity_of(cnt)             # 0..1, 0 best
            soli = solidity_of(cnt)                 # 0..1, 1 best

            # Build mask for ROI to compute color defects
            x0, y0, w, h = cv2.boundingRect(cnt)
            x1, y1 = x0 + w, y0 + h
            # pad ROI a bit but keep in bounds
            pad = 4
            x0p = max(0, x0 - pad); y0p = max(0, y0 - pad)
            x1p = min(frame.shape[1], x1 + pad); y1p = min(frame.shape[0], y1 + pad)

            roi_bgr = frame[y0p:y1p, x0p:x1p]
            mask = np.zeros((y1p - y0p, x1p - x0p), dtype=np.uint8)
            cnt_shifted = cnt - np.array([[x0p, y0p]])
            cv2.drawContours(mask, [cnt_shifted], -1, 255, thickness=cv2.FILLED)

            dE = lab_deltaE(roi_bgr, mask)
            # Defect: color difference larger than threshold inside mask
            defect_mask = ((dE > float(dcol_thr)) & (mask > 0)).astype(np.uint8)
            total_pixels = int(np.count_nonzero(mask))
            defect_pixels = int(np.count_nonzero(defect_mask))
            defect_pct = (100.0 * defect_pixels / total_pixels) if total_pixels > 0 else 0.0

            # Decision
            reasons = []
            ok = True
            if circ < min_circ:
                ok = False; reasons.append(f"circularidad {circ:.2f} < {min_circ:.2f}")
            if ecc > max_ecc:
                ok = False; reasons.append(f"excentricidad {ecc:.2f} > {max_ecc:.2f}")
            if soli < min_soli:
                ok = False; reasons.append(f"solidez {soli:.2f} < {min_soli:.2f}")
            if defect_pct > max_def_pct:
                ok = False; reasons.append(f"defecto {defect_pct:.1f}% > {max_def_pct:.1f}%")

            annotate_object(annotated, (x, y), r, ok, reasons, (circ, ecc, soli, defect_pct))

            # Optional: contour overlay on edges view
            cv2.drawContours(edges_color, [cnt], -1, (0,255,255), 1, cv2.LINE_AA)

        # HUD with current params
        hud = f"Blur={blur_k}  Canny=({c_lo},{c_hi})  Diam=[{dmin},{dmax}]  circ>= {min_circ:.2f}  ecc<= {max_ecc:.2f}  soli>= {min_soli:.2f}  ΔE>{dcol_thr} -> defect  maxDef={max_def_pct:.1f}%"
        cv2.putText(annotated, hud, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (30,255,30), 1, cv2.LINE_AA)

        view = annotated if not show_edges else stack_side_by_side(annotated, edges_color)

        cv2.imshow(WIN_VIEW, view)

        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break
        elif key == ord('s'):
            now = time.time()
            if now - last_save > 0.5:
                cv2.imwrite("mm_snapshot.png", view)
                print("Guardado: mm_snapshot.png")
                last_save = now

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()

```

## 6) Procedimiento paso a paso

### Parte A — Instalación y prueba rápida

1. Crear entorno (opcional) e instalar:

   ```bash
   pip install opencv-python numpy
   ```
2. Guardar el archivo `mm_inspector.py` y ejecutar:

   ```bash
   python mm_inspector.py
   ```

   Si no abre la cámara, cambie `cv2.VideoCapture(0)` a `1` o `2`.

### Parte B — Sintonía básica (en ese orden)

1. **Tamaño:** coloque 1–2 M&M a media distancia. Ajuste **Min/Max diam (px)** hasta enmarcarlos sin tomar objetos pequeños o el fondo.
2. **Bordes:** con **Blur** en 5–9, ajuste **Canny low/high** para que el contorno del M&M salga **continuo** (sin huecos ni ruido).
3. **Circularidad vs. ovalidad:** suba **Min circularity %** y ajuste **Max eccentricity %** para **permitir** la ligera ovalidad típica pero **rechazar** óvalos obvios.
4. **Solidez:** suba **Min solidity %** para que una **mordida** o **faltante de borde** cause rechazo; si genera muchos falsos rechazos por micro-irregularidades, bájelo un poco.
5. **Defecto interno:** eleve **Δcolor thr (Lab)** hasta que **pequeñas variaciones** no cuenten como defecto; luego fije **Max defect %** en un valor que rechace piezas con **zonas sin color** o **cuarteaduras** visibles.

> **Tip didáctico:** observe el texto de métricas sobre cada M&M: `c=… e=… s=… df%=…`. Úselo para justificar sus umbrales.

### Parte C — Casos de prueba guiados

Realice fotos (`s`) y anote parámetros finales para cada caso:

1. **M&M sano (ligeramente ovalado)** → debe salir **OK**.
2. **M&M con muesca/borde roto** → **RECHAZO** por **solidez** baja.
3. **M&M con faltante/raspones de color** → **RECHAZO** por **defecto %** interno.
4. **Iluminación diferente** (más sombras/brillos) → re-ajuste leve de **Δcolor thr** y verifique robustez.
5. **Distancia distinta** (más cerca/lejos) → vuelva a sintonizar **Min/Max diam**.

*(Opcional)* **Calibración mm/pixel:** Coloque una moneda conocida. Mida su diámetro en pixeles (overlay) y calcule `px/mm`. Con eso puede convertir el **rango de diámetro** a **milímetros**.

### Parte D — Análisis y reporte

* Presente una **tabla** por caso: parámetros usados + métricas promedio (`c, e, s, df%`) + decisión.
* Justifique **dos decisiones** que hayan cambiado al mover un único control (p. ej., subir `Min solidity` transformó un OK en RECHAZO con muesca leve).
* Discuta **tres fuentes de error** (p. ej., M&Ms tocándose, brillos especulares, fondo con textura) y proponga **mejoras** (separación morfológica, polarizadores, fondo mate, ROI por color de recubrimiento, CLAHE, etc.).

## 7) Actividad de comprobación (entregable)

1. **Bitácora** (máx. 2 págs.): objetivo, metodología de calibración, tabla de casos, discusión.
2. **4 capturas** (`.png`) con overlay de **OK/RECHAZO** y métricas visibles (uno por cada caso 1–4).
3. **Archivo de parámetros finales** (screenshot de los sliders o listado: blur, canny, diam, circularity, eccentricity, solidity, ΔE, max defect).
4. **Reflexión breve** (5–7 líneas): ¿qué control fue más sensible? ¿qué métrica le pareció más útil para separar defectos reales de “imperfección normal”?

> **Formato de entrega sugerido:** Carpeta `practica-mm/` con `bitacora.pdf`, `captura-1..4.png`, `parametros.txt`.

## 8) Preguntas rápidas (teórico-prácticas)

1. V/F: A mayor **solidez**, menor probabilidad de **mordida** o borde faltante.
2. Numérica: Un M&M tiene ( A=4{,}520 ) px² y ( P=250 ) px. Calcule **circularidad**.
3. MCQ: ¿Qué subiría para tolerar mejor brillos internos sin afectar bordes?
   a) Min circularity  b) Max eccentricity  c) Δcolor thr (Lab)  d) Min solidity
4. Corto: ¿Por qué primero conviene fijar **tamaño** y **bordes** antes de ajustar **solidez** y **defecto interno**?

*(Clave esperada)* 1) V  · 2) (C=\frac{4\pi A}{P^2}\approx \frac{4\pi(4520)}{250^2}\approx 0.91)  · 3) c)  · 4) Porque tamaño/bordes estabilizan la segmentación; las métricas geométricas y de color dependen de una buena detección del contorno.

## 9) Extensiones (opcionales)

* **Separación de objetos tocándose:** watershed o distancia + `morphology`.
* **Compensación de iluminación:** CLAHE o *white balance* sencillo antes de ΔE.
* **Salida a actuador:** publicar **OK/RECHAZO** por socket/serial a **ESP32** para accionar compuertas.

---



